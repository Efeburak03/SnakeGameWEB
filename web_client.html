<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <title>WebSocket Snake Game</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, orientation=landscape">
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            background: #222;
            overflow: hidden;
        }
        #ui {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: fixed;
            inset: 0;
            z-index: 10;
            /* Arka planı bulanık ve görsel ile kapla */
            background: url('assets/bg5.jpg') center center/cover no-repeat;
        }
        #ui::before {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(34,34,34,0.55);
            backdrop-filter: blur(6px);
            z-index: -1;
        }
        #ui h1 {
            margin-bottom: 32px;
            font-size: 2.8em;
            font-weight: 900;
            letter-spacing: 2px;
            color: #fff;
            text-shadow: 0 2px 12px #000a;
        }
        #ui input {
            margin-bottom: 12px;
            padding: 12px 24px;
            font-size: 1.3em;
            border-radius: 10px;
            border: 2px solid #444;
            outline: none;
            background: rgba(255,255,255,0.12);
            color: #fff;
            font-family: 'Segoe UI', Arial, sans-serif;
            box-shadow: 0 2px 8px rgba(0,0,0,0.10);
            transition: border 0.2s, box-shadow 0.2s;
        }
        #ui input:focus {
            border: 2px solid #4caf50;
            box-shadow: 0 2px 12px #4caf5055;
        }
        #ui input.error {
            border: 2px solid #e53935;
        }
        #ui button {
            margin-bottom: 8px;
            padding: 12px 32px;
            font-size: 1.2em;
            border-radius: 10px;
            border: none;
            background: linear-gradient(90deg, #4caf50 60%, #388e3c 100%);
            color: #fff;
            font-weight: bold;
            letter-spacing: 1px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.13);
            transition: background 0.2s, box-shadow 0.2s;
        }
        #ui button:hover, #ui button:focus {
            background: linear-gradient(90deg, #388e3c 60%, #4caf50 100%);
            box-shadow: 0 4px 16px #4caf5055;
        }
        #ui .error-msg {
            color: #e53935;
            font-size: 1.1em;
            margin-bottom: 10px;
            min-height: 24px;
            font-weight: 500;
            text-shadow: 0 1px 4px #000a;
        }
        #game-container {
            margin: 10px auto 0 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        #game {
            background: #111;
            display: block;
            margin: 0 auto;
            border-radius: 12px;
            box-shadow: 0 2px 16px rgba(0,0,0,0.25);
        }
        

        
        .game-message {
            position: absolute;
            left: 0; right: 0; top: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 100;
        }
        .game-message span {
            background: rgba(34,34,34,0.85);
            color: #fff;
            font-size: 2.5em;
            font-family: 'Segoe UI', Arial, sans-serif;
            padding: 24px 48px;
            border-radius: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.18);
        }
        #top-usernames {
            position: fixed;
            left: 160px;
            top: 0;
            width: calc(100vw - 160px);
            height: 48px;
            background: transparent;
            color: #fff;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: flex-start;
            z-index: 15;
            font-size: 1.3em;
            font-family: 'Segoe UI', Arial, sans-serif;
            padding-left: 32px;
            gap: 48px;
            pointer-events: none;
        }
        #top-usernames span {
            background: rgba(34,34,34,0.45);
            border-radius: 8px;
            padding: 6px 18px;
            margin-right: 0;
            pointer-events: auto;
        }
        

        @media (max-width: 900px) {
            #touch-controls {
                display: flex !important;
            }
        }
        #touch-controls {
            display: none;
            position: fixed;
            bottom: 32px;
            right: 32px;
            left: auto;
            width: auto;
            flex-direction: row;
            justify-content: flex-end;
            align-items: flex-end;
            z-index: 1000;
            pointer-events: none;
        }
        .touch-btn {
            width: 56px;
            height: 56px;
            margin: 6px;
            border-radius: 50%;
            background: rgba(34,34,34,0.8);
            color: #fff;
            font-size: 2em;
            border: 2px solid #4caf50;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px #000a;
            pointer-events: auto;
            user-select: none;
            touch-action: manipulation;
        }
        .touch-btn:active {
            background: #4caf50;
            color: #fff;
        }
        .touch-btn-restart {
            background: #e53935;
            border: 2px solid #e53935;
            font-size: 1.5em;
            margin-left: 12px;
        }
        @media (orientation: portrait) {
            body {
                min-width: 100vw;
                min-height: 100vh;
                overflow: hidden;
            }
            #rotate-warning {
                display: flex !important;
            }
        }
        #rotate-warning {
            display: none;
            position: fixed;
            z-index: 20000;
            left: 0; top: 0; right: 0; bottom: 0;
            background: #222c;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 2em;
            text-align: center;
        }
        
                       /* Loading Overlay Stilleri */
               #loading-overlay {
                   position: fixed;
                   top: 0;
                   left: 0;
                   width: 100vw;
                   height: 100vh;
                   background: #000;
                   display: flex;
                   align-items: center;
                   justify-content: center;
                   z-index: 9999;
                   opacity: 0;
                   visibility: hidden;
                   transition: opacity 0.3s ease, visibility 0.3s ease;
               }
               #loading-overlay.show {
                   opacity: 1;
                   visibility: visible;
               }
               .loading-text {
                   color: #ff8c00;
                   font-size: 2em;
                   font-family: 'Segoe UI', Arial, sans-serif;
                   text-align: center;
                   font-weight: bold;
               }

        /* Mod ve Zorluk Seçimi Stilleri */
        #mode-ui, #difficulty-ui {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: fixed;
            inset: 0;
            z-index: 10;
            background: url('assets/bg5.jpg') center center/cover no-repeat;
        }
        #mode-ui::before, #difficulty-ui::before {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(34,34,34,0.55);
            backdrop-filter: blur(6px);
            z-index: -1;
        }
        #mode-ui h1, #difficulty-ui h1 {
            margin-bottom: 32px;
            font-size: 2.8em;
            font-weight: 900;
            letter-spacing: 2px;
            color: #fff;
            text-shadow: 0 2px 12px #000a;
        }
        .mode-buttons, .difficulty-buttons {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
        }
        .mode-btn, .difficulty-btn {
            padding: 20px 30px;
            font-size: 1.2em;
            border-radius: 12px;
            border: 2px solid #444;
            background: rgba(255,255,255,0.1);
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            min-width: 150px;
        }
        .mode-btn h3, .difficulty-btn h3 {
            margin: 0 0 10px 0;
            font-size: 1.3em;
            font-weight: bold;
        }
        .mode-btn p, .difficulty-btn p {
            margin: 0;
            font-size: 0.9em;
            opacity: 0.8;
        }
        .mode-btn:hover, .difficulty-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: #4caf50;
            transform: translateY(-2px);
        }
        .mode-btn.active, .difficulty-btn.active {
            background: #4caf50;
            border-color: #4caf50;
            color: #fff;
            transform: translateY(-2px);
        }
        
        /* Time Attack UI */
        #time-attack-ui {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: #fff;
            padding: 15px;
            border-radius: 10px;
            z-index: 1000;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        #time-attack-ui h3 {
            margin: 0 0 10px 0;
            font-size: 1.2em;
        }
        #time-attack-ui div {
            margin: 5px 0;
            font-size: 1em;
        }
        #time-attack-ui button {
            margin-top: 10px;
            padding: 8px 16px;
            background: #4caf50;
            border: none;
            border-radius: 5px;
            color: #fff;
            cursor: pointer;
        }
        

        





        /* Ana Menü butonu */
        .main-menu-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            padding: 8px 12px;
            background: #ff8c00;
            color: #000;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            z-index: 10;
            display: none;
        }

        /* Chat Sistemi Stilleri */
        #chat-container {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 300px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #4caf50;
            border-radius: 8px;
            z-index: 1000;
            display: none;
            flex-direction: column;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        #chat-container:hover {
            background: rgba(0, 0, 0, 0.8);
        }
        #chat-header {
            background: rgba(76, 175, 80, 0.3);
            padding: 8px 12px;
            border-bottom: 1px solid #4caf50;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            font-weight: bold;
            color: #fff;
        }
        #chat-close {
            background: none;
            border: none;
            color: #fff;
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #chat-close:hover {
            color: #ff6b6b;
        }
        #chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            color: #fff;
            font-size: 12px;
            line-height: 1.4;
        }
        .chat-message {
            margin-bottom: 4px;
            word-wrap: break-word;
        }
        .chat-message .timestamp {
            color: #888;
            font-size: 10px;
            margin-right: 4px;
        }
        .chat-message .player-name {
            font-weight: bold;
            margin-right: 4px;
        }
        .chat-message .message-text {
            color: #fff;
        }
        .chat-message.whisper {
            color: #ffd700;
            font-style: italic;
        }
        #chat-input-container {
            padding: 8px;
            border-top: 1px solid #4caf50;
            border-radius: 0 0 8px 8px;
        }
        #chat-input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #4caf50;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            font-size: 12px;
            outline: none;
        }
        #chat-input:focus {
            border-color: #66bb6a;
            background: rgba(0, 0, 0, 0.7);
        }
        .chat-error {
            color: #ff6b6b;
            font-size: 11px;
            margin-top: 4px;
            display: none;
        }

    </style>
</head>
<body>
    <!-- Kullanıcı Adı Ekranı -->
    <div id="ui">
        <h1>Snake Game</h1>
        <div class="error-msg" id="ui-error"></div>
        <input id="nicknameInput" type="text" maxlength="16" placeholder="Kullanıcı adı" />
        <button id="startBtn">Devam Et</button>
    </div>
    
    <!-- Mod Seçimi Ekranı -->
    <div id="mode-ui" style="display:none;">
        <h1>Oyun Modu Seçin</h1>
        <div class="error-msg" id="mode-error"></div>
        <div class="mode-buttons">
            <button class="mode-btn" data-mode="classic">
                <h3>Klasik Mod</h3>
                <p>Multiplayer competition</p>
            </button>
            <button class="mode-btn" data-mode="timeAttack">
                <h3>Time Attack</h3>
                <p>Solo zaman yarışı</p>
            </button>

        </div>
        <button id="modeStartBtn" style="display:none;">Start Game</button>
    </div>
    
    <!-- Difficulty Selection Screen -->
    <div id="difficulty-ui" style="display:none;">
        <h1>Difficulty Level</h1>
        <div class="error-msg" id="difficulty-error"></div>
        <div class="difficulty-buttons">
            <button class="difficulty-btn" data-difficulty="easy">
                <h3>Easy</h3>
                <p>2 minutes</p>
            </button>
            <button class="difficulty-btn" data-difficulty="medium">
                <h3>Medium</h3>
                <p>1.5 minutes</p>
            </button>
            <button class="difficulty-btn" data-difficulty="hard">
                <h3>Hard</h3>
                <p>1 minute</p>
            </button>
        </div>
        <button id="difficultyStartBtn" style="display:none;">Start Game</button>
    </div>
    

    <div id="top-usernames" style="display:none;"></div>
    
               <!-- Loading Overlay -->
           <div id="loading-overlay">
               <div class="loading-text">LOADING...</div>
           </div>
    
    <div id="game-container" style="display:none; width:100vw; height:100vh;">
        <div style="position:relative; width:100vw; height:100vh;">
            <canvas id="game"></canvas>
            <div id="game-message" class="game-message" style="display:none;"><span></span></div>
            <button id="main-menu-btn" class="main-menu-btn">Main Menu</button>
        </div>
    </div>
    
    <!-- Chat Container -->
    <div id="chat-container">
        <div id="chat-header">
            <span>Chat</span>
            <button id="chat-close">×</button>
        </div>
        <div id="chat-messages"></div>
        <div id="chat-input-container">
            <input type="text" id="chat-input" placeholder="Type your message..." maxlength="100">
            <div class="chat-error" id="chat-error"></div>
        </div>
    </div>
    <div id="rotate-warning">Please rotate your device to landscape mode.<br/>Lütfen cihazınızı yatay konuma çevirin.</div>
    <div id="touch-controls">
        <div style="display:flex; flex-direction:column; align-items:center; justify-content:flex-end;">
            <button class="touch-btn" id="btn-up" style="margin-bottom:2px;">▲</button>
            <div style="display:flex; flex-direction:row; align-items:center;">
                <button class="touch-btn" id="btn-left">◀</button>
                <button class="touch-btn" id="btn-down" style="margin:0 2px;">▼</button>
                <button class="touch-btn" id="btn-right">▶</button>
            </div>
        </div>
        <button class="touch-btn touch-btn-restart" id="btn-restart" style="display:none; align-self:flex-end; margin-left:12px;">⟳</button>
    </div>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
    // --- Oyun parametreleri ---
    let BOARD_WIDTH = 60;
    let BOARD_HEIGHT = 35;
    let CELL_SIZE = 20; // Bu dinamik olacak
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let socket = null;
    let suppressAutoReconnect = false;
    let myId = null;
    let gameState = null;
    let started = false;
    let readySent = false;
    let eliminationTime = null;
    let currentDirection = null; // Başlangıçta null
    let nickname = '';
    let assets = {};
    
    // Time Attack değişkenleri
    let timeAttackState = null;
    let currentGameMode = null;
    let currentDifficulty = null;
    
    // Capture the Flag değişkenleri
    
    let selectedTeam = null;
    let animationTime = 0; // Magnet efektleri için animasyon zamanı
    
    // Chat sistemi değişkenleri
    let chatVisible = false;
    let chatDragging = false;
    let chatDragStart = { x: 0, y: 0 };
    let chatContainer = null;
    let chatInput = null;
    let chatMessages = null;
    let chatError = null;

    // --- Görselleri yükle ---
    const assetFiles = {
        apple: 'assets/elma.png',
        golden: 'assets/golden_apple.png',
        grass: 'assets/çimen.png',
        enemy: 'assets/enemy.png',
        portal: 'assets/portal.png',
        bg: 'assets/bg5.jpg',
        eagle: 'assets/Eagle_500kg.png',
    };
    function loadAssets(cb) {
        let loaded = 0, total = Object.keys(assetFiles).length;
        for (const [key, src] of Object.entries(assetFiles)) {
            const img = new Image();
            img.onload = () => { assets[key] = img; if (++loaded === total) cb(); };
            img.onerror = () => { loaded++; if (loaded === total) cb(); };
            img.src = src;
        }
    }

    // --- WebSocket bağlantısı ---
    function connect() {
        if (socket) {
            socket.disconnect();
        }
        socket = io();
        
        socket.on('connect', () => {
            // Oyun başlatılırken yeniden bağlanmaya izin ver
            suppressAutoReconnect = false;
            if (currentGameMode === 'timeAttack') {
                socket.emit('start_time_attack', {client_id: nickname, difficulty: currentDifficulty});

            } else if (currentGameMode === 'classic') {
                socket.emit('join', {client_id: nickname});
            }
        });
        
        socket.on('state', (state) => {
            // Loading overlay'i gizle
            const loadingOverlay = document.getElementById('loading-overlay');
            loadingOverlay.classList.remove('show');
            
            // Yem yeme kontrolü - önceki state ile karşılaştır
            if (gameState && gameState.food && state.food) {
                // Yem sayısı azaldıysa patlama efekti oluştur
                if (state.food.length < gameState.food.length) {
                    // Yenen yemi bul
                    for (const oldFood of gameState.food) {
                        if (!state.food.some(f => f[0] === oldFood[0] && f[1] === oldFood[1])) {
                            const x = oldFood[0] * CELL_SIZE + CELL_SIZE / 2;
                            const y = oldFood[1] * CELL_SIZE + CELL_SIZE / 2;
                            createExplosion(x, y, '#ff0000');
                            break;
                        }
                    }
                }
            }
            
            gameState = state;
            if (!myId) myId = nickname;
            // Oyun durumu değiştiğinde readySent'i sıfırla
            readySent = false;
            
            updateTopUsernames();
            updateRestartButton();
        });
        
        // Time Attack event listener'ları
        socket.on('time_attack_started', (data) => {
            // Loading overlay'i gizle
            const loadingOverlay = document.getElementById('loading-overlay');
            loadingOverlay.classList.remove('show');
            
            currentGameMode = 'timeAttack';
            currentDifficulty = data.difficulty;
            showTimeAttackUI();
        });
        
        socket.on('time_attack_state', (state) => {
            timeAttackState = state;
            // Eğer oyun aktifse canlanma mesajını gizle
            if (state.game_active) {
                hideRespawnMessage();
            }
        });
        
        // Capture the Flag event listener'ları

        
        socket.on('error', (err) => {
            // Loading overlay'i gizle
            const loadingOverlay = document.getElementById('loading-overlay');
            loadingOverlay.classList.remove('show');
            
            const errorDiv = document.getElementById('ui-error');
            errorDiv.textContent = err.message || 'Bağlantı hatası!';
            document.getElementById('ui').style.display = 'flex';
            document.getElementById('game-container').style.display = 'none';
            document.getElementById('top-usernames').style.display = 'none';
        });
        
        // Chat Socket.IO event listeners
        socket.on('chat_message', (chatData) => {
            addChatMessage(chatData);
        });
        
        socket.on('chat_history', (messages) => {
            chatMessages.innerHTML = '';
            messages.forEach(msg => {
                addChatMessage(msg);
            });
        });
        
        socket.on('chat_error', (error) => {
            showChatError(error.message);
        });
        
        socket.on('disconnect', () => {
            // Loading overlay'i gizle
            const loadingOverlay = document.getElementById('loading-overlay');
            loadingOverlay.classList.remove('show');
            // Ana menüye dönüşte tekrar bağlanma
            if (!suppressAutoReconnect) {
            setTimeout(connect, 1000);
            }
        });
        

    }

    // --- Oyun çizimi ---
    let animationFrameId = null;
    
    function startRenderLoop() {
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
        
        let lastTime = 0;
        
        function renderLoop(currentTime) {
            if (currentTime - lastTime < 16.67) {
                animationFrameId = requestAnimationFrame(renderLoop);
                return;
            }
            lastTime = currentTime;
            
            animationTime += 0.016;
            
            if (currentGameMode === 'timeAttack' && timeAttackState) {
                drawTimeAttack();
            } else if (gameState) {
                draw();
            }
            
            animationFrameId = requestAnimationFrame(renderLoop);
        }
        
        renderLoop(0);
    }
    
    // Hex rengi alfa ile RGBA biçimine çevirir
    function hexToRgba(hex, alpha) {
        if (!hex) return `rgba(255,255,255,${alpha})`;
        let h = hex.replace('#', '');
        if (h.length === 3) h = h.split('').map(c => c + c).join('');
        const num = parseInt(h, 16);
        const r = (num >> 16) & 255;
        const g = (num >> 8) & 255;
        const b = num & 255;
        return `rgba(${r},${g},${b},${alpha})`;
    }
    
    
    function stopRenderLoop() {
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
    }
    
    function draw() {
        // Canvas'ı tamamen temizle
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Sadece klasik mod için arka plan - optimize edilmiş
        if (assets.bg) {
            ctx.fillStyle = ctx.createPattern(assets.bg, 'repeat');
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        } else if (assets.grass) {
            ctx.fillStyle = ctx.createPattern(assets.grass, 'repeat');
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        
        if (!gameState) {
            return;
        }
        
        // Yılanlar - renk bazlı efektlerle
        if (gameState.snakes) {
            for (const [pid, snake] of Object.entries(gameState.snakes)) {
                if (!snake || snake.length === 0) continue;
                
                const frozen = gameState.powerup_timers && gameState.powerup_timers[pid] && gameState.powerup_timers[pid]["frozen"] > 0;
                
                // Renk bilgilerini al
                let colorInfo = null;
                if (gameState.color_info && gameState.color_info[pid]) {
                    colorInfo = gameState.color_info[pid];
                } else {
                    // Geriye uyumluluk için varsayılan renk
                    const color = frozen ? '#888' : (pid === myId ? 'lime' : 'yellow');
                    colorInfo = { hex: color, effect: "nature" };
                }
                
                // Renk bazlı efektli çizim
                if (colorInfo && colorInfo.effect) {
                    drawSnakeWithColorEffects(ctx, snake, colorInfo, pid === myId);
                } else {
                    // Eski sistem için fallback
                    const color = frozen ? '#888' : (pid === myId ? 'lime' : 'yellow');
                    drawSnakeWithEffects(ctx, snake, color, pid === myId);
                }
                
                // Renk bazlı parçacık efektleri
                if (!frozen) {
                    if (colorInfo && colorInfo.effect) {
                        createColorBasedParticles(snake, colorInfo);
                    } else {
                        const color = frozen ? '#888' : (pid === myId ? 'lime' : 'yellow');
                        createSnakeParticles(snake, color);
                    }
                    
                    // Speed power-up aktifse nebula smoke efekti
                    if (gameState.powerup_timers && gameState.powerup_timers[pid] && 
                        gameState.powerup_timers[pid]["speed"] > 0 && snake.length > 0) {
                        const head = snake[0];
                        let smokeX = head[0] * CELL_SIZE + CELL_SIZE / 2;
                        let smokeY = head[1] * CELL_SIZE + CELL_SIZE / 2;
                        
                        // Yılanın hareket yönünü hesapla ve dumanı arkasından çıkar
                        if (snake.length > 1) {
                            const neck = snake[1];
                            const dx = head[0] - neck[0];
                            const dy = head[1] - neck[1];
                            
                            // Dumanı yılanın arkasından çıkar
                            smokeX = head[0] * CELL_SIZE + CELL_SIZE / 2 - dx * CELL_SIZE * 0.3;
                            smokeY = head[1] * CELL_SIZE + CELL_SIZE / 2 - dy * CELL_SIZE * 0.3;
                        }
                        
                        createSmokeEffect(smokeX, smokeY, 'nebula');
                    }
                    
                    // Shield power-up aktifse aura efekti
                    if (gameState.powerup_timers && gameState.powerup_timers[pid] && 
                        gameState.powerup_timers[pid]["shield"] > 0 && snake.length > 0) {
                        const head = snake[0];
                        const headX = head[0] * CELL_SIZE;
                        const headY = head[1] * CELL_SIZE;
                        createShieldAura(headX, headY, pid);
                    } else {
                        // Shield aktif değilse aura'yı kaldır
                        removeShieldAura(pid);
                    }
                }
            }
        }
        
        // İzler (trails) - her yılanın kendi rengine göre renklendir
        if (gameState.trails) {
            for (const [pid, trail] of Object.entries(gameState.trails)) {
                if (!trail || trail.length === 0) continue;

                const isFrozen = !!(gameState.powerup_timers && gameState.powerup_timers[pid] && gameState.powerup_timers[pid]["frozen"] > 0);

                // Öncelik: color_info.effect.trail → color_info.hex → varsayılan(myId lime / diğerleri yellow)
                let colorHex = null;
                if (!isFrozen && gameState.color_info && gameState.color_info[pid]) {
                    const ci = gameState.color_info[pid];
                    const eff = (typeof COLOR_EFFECTS !== 'undefined') ? COLOR_EFFECTS[ci.effect] : null;
                    colorHex = (eff && eff.trail) ? eff.trail : (ci.hex || null);
                }
                if (!colorHex) {
                    colorHex = isFrozen ? '#888888' : (pid === myId ? 'lime' : 'yellow');
                }

                ctx.fillStyle = hexToRgba(colorHex, 0.5);
                for (const seg of trail) {
                    ctx.fillRect(seg[0] * CELL_SIZE, seg[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }
        }
        
        // Engeller (yılanlardan sonra çiz)
        if (gameState.obstacles) {
            for (const obs of gameState.obstacles) {
                const [ox, oy] = obs.pos;
                const size = CELL_SIZE * 1.5;
                const offset = (size - CELL_SIZE) / 2;
                if (obs.type === 'slow') {
                    // Etkileşimli Mavi Sis Efekti
                    const x = ox * CELL_SIZE + CELL_SIZE/2;
                    const y = oy * CELL_SIZE + CELL_SIZE/2;
                    const size = CELL_SIZE;
                    const time = Date.now() * 0.004;
                    
                    // Yılanın mesafesini hesapla
                    let distance = 999;
                    let intensity = 0.3; // Minimum yoğunluk
                    if (gameState.snakes && myId && gameState.snakes[myId] && gameState.snakes[myId].length > 0) {
                        const [hx, hy] = gameState.snakes[myId][0];
                        distance = Math.abs(hx - ox) + Math.abs(hy - oy);
                        
                        // Mesafeye göre yoğunluk hesapla (yakın = yoğun)
                        if (distance <= 3) {
                            intensity = 1.0; // Tam yoğunluk
                        } else if (distance <= 6) {
                            intensity = 0.3 + 0.7 * (1 - (distance - 3) / 3);
                        }
                    }
                    
                    // Dış glow efekti - mavi sis
                    const glowSize = size * 2.5 * intensity;
                    const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, glowSize/2);
                    glowGradient.addColorStop(0, `rgba(100, 150, 255, ${0.9 * intensity})`);
                    glowGradient.addColorStop(0.3, `rgba(80, 120, 220, ${0.7 * intensity})`);
                    glowGradient.addColorStop(0.6, `rgba(60, 100, 200, ${0.5 * intensity})`);
                    glowGradient.addColorStop(1, 'rgba(40, 80, 180, 0)');
                    
                    ctx.fillStyle = glowGradient;
                    ctx.fillRect(x - glowSize/4, y - glowSize/4, size + glowSize/2, size + glowSize/2);
                    
                    // Ana sis - organik mavi sis şekli
                    ctx.save();
                    ctx.globalAlpha = 0.8 * intensity;
                    
                    // Sis parçacıkları - rastgele dağılım
                    const particleCount = Math.floor(15 * intensity);
                    for (let i = 0; i < particleCount; i++) {
                        const particleX = x + (Math.random() - 0.5) * size * 1.2;
                        const particleY = y + (Math.random() - 0.5) * size * 1.2;
                        const particleSize = Math.random() * 4 + 2;
                        const particleAlpha = Math.random() * 0.6 + 0.2;
                        
                        ctx.fillStyle = `rgba(120, 180, 255, ${particleAlpha * intensity})`;
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, particleSize, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    
                    // Sis bulutları - daha büyük parçacıklar
                    const cloudCount = Math.floor(8 * intensity);
                    for (let i = 0; i < cloudCount; i++) {
                        const cloudX = x + (Math.random() - 0.5) * size * 0.8;
                        const cloudY = y + (Math.random() - 0.5) * size * 0.8;
                        const cloudSize = Math.random() * 8 + 4;
                        const cloudAlpha = Math.random() * 0.4 + 0.3;
                        
                        ctx.fillStyle = `rgba(100, 150, 230, ${cloudAlpha * intensity})`;
                        ctx.beginPath();
                        ctx.arc(cloudX, cloudY, cloudSize, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                    
                    // Sis hareketi - yukarı doğru yükselen efekt
                    const riseEffect = Math.sin(time * 0.5) * 0.3;
                    ctx.save();
                    ctx.globalAlpha = 0.6 * intensity;
                    
                    for (let i = 0; i < 5; i++) {
                        const riseX = x + (Math.random() - 0.5) * size * 0.6;
                        const riseY = y + (Math.random() - 0.5) * size * 0.6 + riseEffect * 10;
                        const riseSize = Math.random() * 6 + 3;
                        
                        ctx.fillStyle = `rgba(80, 120, 200, ${0.4 * intensity})`;
                        ctx.beginPath();
                        ctx.arc(riseX, riseY, riseSize, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                    
                    // Dönen manyetik parçacıklar (yakın mesafede)
                    if (distance <= 4) {
                        const magneticCount = Math.floor(6 * intensity);
                        for (let i = 0; i < magneticCount; i++) {
                            const angle = time * 0.8 + (i * Math.PI * 2 / magneticCount);
                            const magneticRadius = size * 0.7;
                            const magneticX = x + Math.cos(angle) * magneticRadius;
                            const magneticY = y + Math.sin(angle) * magneticRadius;
                            
                            ctx.save();
                            ctx.globalAlpha = 0.8 * intensity;
                            ctx.fillStyle = '#80b0ff';
                            ctx.beginPath();
                            ctx.arc(magneticX, magneticY, 3, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.restore();
                        }
                    }
                    
                    // Çekim efekti - yılan çok yakınsa
                    if (distance <= 2) {
                        const attractionSize = size * 2;
                        const attractionGradient = ctx.createRadialGradient(x, y, 0, x, y, attractionSize);
                        attractionGradient.addColorStop(0, `rgba(100, 150, 255, ${0.3 * intensity})`);
                        attractionGradient.addColorStop(1, 'rgba(100, 150, 255, 0)');
                        
                        ctx.fillStyle = attractionGradient;
                        ctx.fillRect(x - attractionSize/2, y - attractionSize/2, attractionSize, attractionSize);
                    }
                } else if (obs.type === 'enemy' && assets.enemy) {
                    ctx.drawImage(assets.enemy, ox*CELL_SIZE - offset, oy*CELL_SIZE - offset, size, size);
                }
                else if (obs.type === 'hidden_wall') {
                    // Gizli duvarlar yılanın başının 6 blok yakınında görünür (daha uzak mesafe)
                    let show = false;
                    let distance = 0;
                    if (gameState.snakes && myId && gameState.snakes[myId] && gameState.snakes[myId].length > 0) {
                        const [hx, hy] = gameState.snakes[myId][0];
                        distance = Math.abs(hx - ox) + Math.abs(hy - oy);
                        if (distance <= 6) show = true; // Mesafeyi 4'ten 6'ya çıkardık
                    }
                    if (show) {
                        const x = ox * CELL_SIZE;
                        const y = oy * CELL_SIZE;
                        const size = CELL_SIZE;
                        const time = Date.now() * 0.003; // Daha yavaş animasyon
                        
                        // Kademeli görünürlük (mesafeye göre) - daha yumuşak geçiş
                        const visibility = Math.max(0.65, 1 - (distance / 8)); // Başlangıç parlaklığını artırdık, mesafeyi uzattık
                        
                        // ÇOK DAHA PARLAK Glow efekti
                        const glowSize = size * 3.5; // Glow boyutunu artırdık
                        const glowGradient = ctx.createRadialGradient(
                            x + size/2, y + size/2, 0,
                            x + size/2, y + size/2, glowSize/2
                        );
                        glowGradient.addColorStop(0, `rgba(255, 165, 0, ${1.0 * visibility})`); // Turuncu
                        glowGradient.addColorStop(0.2, `rgba(255, 140, 0, ${0.9 * visibility})`);
                        glowGradient.addColorStop(0.4, `rgba(255, 120, 0, ${0.7 * visibility})`);
                        glowGradient.addColorStop(0.7, `rgba(255, 100, 0, ${0.4 * visibility})`);
                        glowGradient.addColorStop(1, 'rgba(255, 80, 0, 0)');
                        
                        ctx.fillStyle = glowGradient;
                        ctx.fillRect(x - glowSize/3, y - glowSize/3, size + glowSize/1.5, size + glowSize/1.5);
                        
                        // Ana duvar - ÇOK DAHA PARLAK gradient
                        const wallGradient = ctx.createLinearGradient(x, y, x + size, y + size);
                        wallGradient.addColorStop(0, `rgba(255, 165, 0, ${1.0 * visibility})`); // Turuncu
                        wallGradient.addColorStop(0.3, `rgba(255, 140, 0, ${0.98 * visibility})`);
                        wallGradient.addColorStop(0.7, `rgba(255, 120, 0, ${0.98 * visibility})`);
                        wallGradient.addColorStop(1, `rgba(255, 100, 0, ${1.0 * visibility})`);
                        
                        ctx.fillStyle = wallGradient;
                        ctx.fillRect(x, y, size, size);
                        
                        // ÇOK DAHA PARLAK Kenarlık - pulse animasyonu
                        const borderAlpha = 0.95 + 0.05 * Math.sin(time * 1.2); // Daha yavaş pulse
                        ctx.strokeStyle = `rgba(255, 255, 255, ${borderAlpha * visibility})`; // Beyaz kenarlık
                        ctx.lineWidth = 5; // Daha kalın kenarlık
                        ctx.strokeRect(x + 1, y + 1, size - 2, size - 2);
                        
                        // İkinci kenarlık - dış glow efekti
                        ctx.strokeStyle = `rgba(255, 200, 100, ${0.6 * visibility})`; // Turuncu ton
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x - 1, y - 1, size + 2, size + 2);
                        
                        // İç detay - daha parlak çapraz çizgiler
                        ctx.strokeStyle = `rgba(255, 255, 255, ${0.7 * visibility})`; // Daha parlak
                        ctx.lineWidth = 2; // Daha kalın
                        ctx.beginPath();
                        ctx.moveTo(x + 4, y + 4);
                        ctx.lineTo(x + size - 4, y + size - 4);
                        ctx.moveTo(x + size - 4, y + 4);
                        ctx.lineTo(x + 4, y + size - 4);
                        ctx.stroke();
                        
                        // Merkez nokta - dikkat çekici
                        ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * visibility})`;
                        ctx.beginPath();
                        ctx.arc(x + size/2, y + size/2, 3, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Uyarı işareti - mesafe 3'ten azsa
                        if (distance <= 3) {
                            ctx.fillStyle = `rgba(255, 255, 0, ${0.8 * visibility})`; // Sarı uyarı
                            ctx.font = 'bold 12px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('!', x + size/2, y + size/2 + 4);
                        }
                    }
                }
            }
        }
        
        // Portallar
        if (gameState.portals) {
            for (const [a, b] of gameState.portals) {
                if (assets.portal) {
                    const size = CELL_SIZE * 1.2;
                    const offset = (size - CELL_SIZE) / 2;
                    ctx.drawImage(assets.portal, a[0]*CELL_SIZE - offset, a[1]*CELL_SIZE - offset, size, size);
                    ctx.drawImage(assets.portal, b[0]*CELL_SIZE - offset, b[1]*CELL_SIZE - offset, size, size);
                } else {
                    ctx.fillStyle = '#80f';
                    ctx.fillRect(a[0]*CELL_SIZE, a[1]*CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    ctx.fillRect(b[0]*CELL_SIZE, b[1]*CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }
        }
        
        // Yemler - Uzay temalı kırmızı parıltılı yuvarlak
        if (gameState.food) {
            for (const [fx, fy] of gameState.food) {
                const x = fx * CELL_SIZE + CELL_SIZE/2;
                const y = fy * CELL_SIZE + CELL_SIZE/2;
                const radius = CELL_SIZE/2;
                const time = Date.now() * 0.005;
                
                // Dış glow efekti - kırmızı parıltı (daha parlak)
                const glowRadius = radius * 2.2;
                const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, glowRadius);
                glowGradient.addColorStop(0, 'rgba(255, 30, 30, 1.0)');
                glowGradient.addColorStop(0.3, 'rgba(255, 60, 60, 0.8)');
                glowGradient.addColorStop(0.6, 'rgba(255, 100, 100, 0.5)');
                glowGradient.addColorStop(1, 'rgba(255, 50, 50, 0)');
                
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(x, y, glowRadius, 0, 2 * Math.PI);
                ctx.fill();
                
                // Ana yem - gradient kırmızı daire (daha parlak)
                const foodGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                foodGradient.addColorStop(0, 'rgba(255, 100, 100, 1)');
                foodGradient.addColorStop(0.5, 'rgba(255, 60, 60, 0.95)');
                foodGradient.addColorStop(1, 'rgba(220, 30, 30, 0.9)');
                
                ctx.fillStyle = foodGradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fill();
                
                // İç parıltı - pulse animasyonu (daha parlak)
                const pulse = 0.7 + 0.3 * Math.sin(time * 2);
                const innerRadius = radius * 0.7;
                const innerGradient = ctx.createRadialGradient(x, y, 0, x, y, innerRadius);
                innerGradient.addColorStop(0, `rgba(255, 200, 200, ${pulse})`);
                innerGradient.addColorStop(1, 'rgba(255, 150, 150, 0)');
                
                ctx.fillStyle = innerGradient;
                ctx.beginPath();
                ctx.arc(x, y, innerRadius, 0, 2 * Math.PI);
                ctx.fill();
                
                // Kenarlık - parıltılı çizgi (daha parlak)
                ctx.strokeStyle = `rgba(255, 220, 220, ${0.9 + 0.1 * Math.sin(time * 3)})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.stroke();
            }
        } else {
            // Yem yok
        }
        
        // Altın elma - Sarı parıltılı yuvarlak
        if (gameState.golden_food) {
            const [gx, gy] = gameState.golden_food;
            const x = gx * CELL_SIZE + CELL_SIZE/2;
            const y = gy * CELL_SIZE + CELL_SIZE/2;
            const radius = CELL_SIZE/2;
            const time = Date.now() * 0.006;
            
            // Dış glow efekti - sarı parıltı
            const glowRadius = radius * 2.0;
            const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, glowRadius);
            glowGradient.addColorStop(0, 'rgba(255, 255, 50, 0.9)');
            glowGradient.addColorStop(0.5, 'rgba(255, 255, 100, 0.5)');
            glowGradient.addColorStop(1, 'rgba(255, 255, 50, 0)');
            
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(x, y, glowRadius, 0, 2 * Math.PI);
            ctx.fill();
            
            // Ana altın elma - gradient sarı daire
            const goldenGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
            goldenGradient.addColorStop(0, 'rgba(255, 255, 100, 1)');
            goldenGradient.addColorStop(0.6, 'rgba(255, 215, 0, 0.95)');
            goldenGradient.addColorStop(1, 'rgba(255, 165, 0, 0.9)');
            
            ctx.fillStyle = goldenGradient;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fill();
            
            // İç parıltı - pulse animasyonu
            const pulse = 0.7 + 0.3 * Math.sin(time * 2.5);
            const innerRadius = radius * 0.7;
            const innerGradient = ctx.createRadialGradient(x, y, 0, x, y, innerRadius);
            innerGradient.addColorStop(0, `rgba(255, 255, 200, ${pulse})`);
            innerGradient.addColorStop(1, 'rgba(255, 255, 150, 0)');
            
            ctx.fillStyle = innerGradient;
            ctx.beginPath();
            ctx.arc(x, y, innerRadius, 0, 2 * Math.PI);
            ctx.fill();
            
            // Kenarlık - parıltılı çizgi
            ctx.strokeStyle = `rgba(255, 255, 220, ${0.9 + 0.1 * Math.sin(time * 3)})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Dönen parıltı efektleri
            const sparkleCount = 8;
            for (let i = 0; i < sparkleCount; i++) {
                const angle = time * 1.5 + (i * Math.PI * 2 / sparkleCount);
                const sparkleRadius = radius * 1.3;
                const sparkleX = x + Math.cos(angle) * sparkleRadius;
                const sparkleY = y + Math.sin(angle) * sparkleRadius;
                
                ctx.save();
                ctx.globalAlpha = 0.8 * pulse;
                ctx.fillStyle = '#ffff80';
                ctx.beginPath();
                ctx.arc(sparkleX, sparkleY, 2, 0, 2 * Math.PI);
                ctx.fill();
                ctx.restore();
            }
        }
        
        // Remaining time
        if (gameState.time_left !== undefined) {
            ctx.fillStyle = 'yellow';
            ctx.font = '24px Arial';
            ctx.fillText('Time: ' + (gameState.time_left||0) + 's', canvas.width/2-60, 30);
        }
        
        // Game message display
        const msgDiv = document.getElementById('game-message');
        if (gameState.active && myId && !gameState.active[myId]) {
            msgDiv.style.display = 'flex';
            msgDiv.querySelector('span').textContent = 'Eliminated! Press Enter to continue';
        } else if (gameState.waiting_for_restart) {
            msgDiv.style.display = 'flex';
            let winnerName = gameState.winner_id;
            let winnerScore = gameState.scores && winnerName ? gameState.scores[winnerName] : '';
            if (!winnerName || winnerName === '-') winnerName = 'None';
            // Show winner and score when time runs out
            if (readySent) {
            msgDiv.querySelector('span').textContent =
                    'Time\'s up! Winner: ' + winnerName + (winnerScore !== '' ? ' (' + winnerScore + ' points)' : '') + '\n' +
                    'Get ready to start the game';
            } else {
                msgDiv.querySelector('span').textContent =
                    'Time\'s up! Winner: ' + winnerName + (winnerScore !== '' ? ' (' + winnerScore + ' points)' : '') + '\n' +
                    "Press Enter to start";
            }
        } else {
            msgDiv.style.display = 'none';
        }
        
        // Power-up'lar - animasyonlu
        if (gameState.powerups) {
            for (const pu of gameState.powerups) {
                drawAnimatedPowerup(ctx, pu, animationTime);
            }
        }
        
        // Magnet efektleri - gelişmiş manyetik alan ve çekim efektleri
        if (gameState.magnet_effects) {
            for (const [playerId, effect] of Object.entries(gameState.magnet_effects)) {
                const headPos = effect.head_pos;
                const headX = headPos[0] * CELL_SIZE + CELL_SIZE/2;
                const headY = headPos[1] * CELL_SIZE + CELL_SIZE/2;
                
                const time = Date.now() * 0.005;
                const radius = CELL_SIZE * 2;
                
                // Gelişmiş manyetik aura - gradient ve pulse efekti
                ctx.save();
                const pulse = 0.7 + 0.3 * Math.sin(time * 3);
                
                // Dış manyetik halka - gradient
                const outerGradient = ctx.createRadialGradient(headX, headY, 0, headX, headY, radius);
                outerGradient.addColorStop(0, 'rgba(204, 0, 204, 0.8)');
                outerGradient.addColorStop(0.5, 'rgba(128, 0, 128, 0.6)');
                outerGradient.addColorStop(1, 'rgba(64, 0, 64, 0)');
                
                ctx.fillStyle = outerGradient;
                ctx.globalAlpha = pulse;
                ctx.beginPath();
                ctx.arc(headX, headY, radius, 0, 2 * Math.PI);
                ctx.fill();
                
                // İç manyetik halka - daha parlak
                const innerGradient = ctx.createRadialGradient(headX, headY, 0, headX, headY, radius * 0.6);
                innerGradient.addColorStop(0, 'rgba(255, 0, 255, 0.9)');
                innerGradient.addColorStop(0.7, 'rgba(204, 0, 204, 0.7)');
                innerGradient.addColorStop(1, 'rgba(128, 0, 128, 0)');
                
                ctx.fillStyle = innerGradient;
                ctx.globalAlpha = pulse * 0.8;
                ctx.beginPath();
                ctx.arc(headX, headY, radius * 0.6, 0, 2 * Math.PI);
                ctx.fill();
                
                // Dönen manyetik parçacıklar
                const particleCount = 12;
                for (let i = 0; i < particleCount; i++) {
                    const angle = time * 2 + (i * Math.PI * 2 / particleCount);
                    const particleRadius = radius * 0.8;
                    const particleX = headX + Math.cos(angle) * particleRadius;
                    const particleY = headY + Math.sin(angle) * particleRadius;
                    
                    ctx.save();
                    ctx.globalAlpha = 0.8 * pulse;
                    ctx.fillStyle = '#ff00ff';
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, 3, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Parçacık glow efekti
                    ctx.shadowColor = '#ff00ff';
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, 1, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.restore();
                }
                
                // Manyetik alan çizgileri - daha gelişmiş
                ctx.strokeStyle = '#ff00ff';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.6 * pulse;
                
                for (let i = 0; i < 8; i++) {
                    const angle = time + (i * Math.PI / 4);
                    const startX = headX + Math.cos(angle) * (radius * 0.2);
                    const startY = headY + Math.sin(angle) * (radius * 0.2);
                    const endX = headX + Math.cos(angle) * radius;
                    const endY = headY + Math.sin(angle) * radius;
                    
                    // Gradient çizgi
                    const lineGradient = ctx.createLinearGradient(startX, startY, endX, endY);
                    lineGradient.addColorStop(0, 'rgba(255, 0, 255, 0.9)');
                    lineGradient.addColorStop(1, 'rgba(128, 0, 128, 0.3)');
                    
                    ctx.strokeStyle = lineGradient;
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
                
                ctx.restore();
                
                // Çekilen yemler için gelişmiş efektler
                if (effect.attracted_foods) {
                    for (const foodEffect of effect.attracted_foods) {
                        const startPos = foodEffect.start_pos;
                        const endPos = foodEffect.end_pos;
                        const progress = foodEffect.progress || 0;
                        
                        // Yem pozisyonunu hesapla
                        const currentX = startPos[0] + (endPos[0] - startPos[0]) * progress;
                        const currentY = startPos[1] + (endPos[1] - startPos[1]) * progress;
                        const foodX = currentX * CELL_SIZE + CELL_SIZE/2;
                        const foodY = currentY * CELL_SIZE + CELL_SIZE/2;
                        
                        // Çekim izi - gelişmiş gradient iz
                        ctx.save();
                        const trailLength = 15;
                        for (let i = 0; i < trailLength; i++) {
                            const trailProgress = progress - (i * 0.03);
                            if (trailProgress > 0) {
                                const trailX = startPos[0] + (endPos[0] - startPos[0]) * trailProgress;
                                const trailY = startPos[1] + (endPos[1] - startPos[1]) * trailProgress;
                                const trailScreenX = trailX * CELL_SIZE + CELL_SIZE/2;
                                const trailScreenY = trailY * CELL_SIZE + CELL_SIZE/2;
                                
                                const trailAlpha = 0.8 * (1 - trailProgress) * (1 - i / trailLength);
                                const trailSize = 4 * (1 - i / trailLength);
                                
                                // Gradient trail
                                const trailGradient = ctx.createRadialGradient(trailScreenX, trailScreenY, 0, trailScreenX, trailScreenY, trailSize);
                                trailGradient.addColorStop(0, `rgba(255, 0, 255, ${trailAlpha})`);
                                trailGradient.addColorStop(0.5, `rgba(204, 0, 204, ${trailAlpha * 0.7})`);
                                trailGradient.addColorStop(1, `rgba(128, 0, 128, 0)`);
                                
                                ctx.fillStyle = trailGradient;
                                ctx.beginPath();
                                ctx.arc(trailScreenX, trailScreenY, trailSize, 0, 2 * Math.PI);
                                ctx.fill();
                            }
                        }
                        ctx.restore();
                        
                        // Çekilen yem - gelişmiş manyetik efektler
                        ctx.save();
                        
                        // Yem glow efekti
                        ctx.shadowColor = '#ff00ff';
                        ctx.shadowBlur = 15;
                        ctx.fillStyle = '#ff0066';
                        ctx.globalAlpha = 0.9;
                        ctx.beginPath();
                        ctx.arc(foodX, foodY, CELL_SIZE/2 * (1 + 0.3 * Math.sin(Date.now() * 0.01)), 0, 2*Math.PI);
                        ctx.fill();
                        
                        // Yemin etrafında dönen manyetik parçacıklar
                        const foodParticleCount = 8;
                        for (let i = 0; i < foodParticleCount; i++) {
                            const particleAngle = Date.now() * 0.008 + (i * Math.PI * 2 / foodParticleCount);
                            const particleRadius = CELL_SIZE * 1.2;
                            const particleX = foodX + Math.cos(particleAngle) * particleRadius;
                            const particleY = foodY + Math.sin(particleAngle) * particleRadius;
                            
                            ctx.save();
                            ctx.globalAlpha = 0.8 * Math.sin(Date.now() * 0.01 + i);
                            ctx.fillStyle = '#ff00ff';
                            ctx.beginPath();
                            ctx.arc(particleX, particleY, 2, 0, 2 * Math.PI);
                            ctx.fill();
                            
                            // Parçacık glow efekti
                            ctx.shadowColor = '#ff00ff';
                            ctx.shadowBlur = 6;
                            ctx.beginPath();
                            ctx.arc(particleX, particleY, 1, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.restore();
                        }
                        
                        // Yem etrafında manyetik halkalar
                        const ringCount = 3;
                        for (let i = 0; i < ringCount; i++) {
                            const ringRadius = CELL_SIZE * (0.8 + i * 0.3);
                            const ringAlpha = 0.4 * (1 - i / ringCount);
                            const ringRotation = Date.now() * 0.003 + i * 0.5;
                            
                            ctx.save();
                            ctx.strokeStyle = `rgba(255, 0, 255, ${ringAlpha})`;
                            ctx.lineWidth = 2;
                            ctx.globalAlpha = ringAlpha;
                            ctx.beginPath();
                            ctx.arc(foodX, foodY, ringRadius, 0, 2 * Math.PI);
                            ctx.stroke();
                            ctx.restore();
                        }
                        
                        ctx.restore();
                    }
                }
            }
        }
        
        // Particle ve explosion efektlerini çiz
        updateAndDrawParticles(ctx);
        updateAndDrawExplosions(ctx);
        updateAndDrawSmoke(ctx);
        updateAndDrawShieldAuras(ctx); // Shield aurasını çiz
    }

    // --- Skor tablosu ---
    function updateScoreboard() { /* Artık kullanılmıyor */ }

    function updateTopUsernames() {
        const topDiv = document.getElementById('top-usernames');
        if (!gameState || !gameState.scores) { topDiv.innerHTML = ''; return; }
        let html = '';
        for (const pid of Object.keys(gameState.scores)) {
            html += `<span>${pid}: ${gameState.scores[pid]}</span>`;
        }
        topDiv.innerHTML = html;
    }

    // --- Dinamik boyutlandırma fonksiyonu ---
    function resizeGameCanvas() {
        // game-container boyutlarına göre dinamik hesaplama
        const gameContainer = document.getElementById('game-container');
        if (gameContainer) {
            const containerRect = gameContainer.getBoundingClientRect();
            const w = containerRect.width;
            const h = containerRect.height;
            CELL_SIZE = Math.floor(Math.min(w / BOARD_WIDTH, h / BOARD_HEIGHT));
            canvas.width = CELL_SIZE * BOARD_WIDTH;
            canvas.height = CELL_SIZE * BOARD_HEIGHT;
        } else {
            // Fallback: window boyutları
            const w = window.innerWidth;
            const h = window.innerHeight;
            CELL_SIZE = Math.floor(Math.min(w / BOARD_WIDTH, h / BOARD_HEIGHT));
            canvas.width = CELL_SIZE * BOARD_WIDTH;
            canvas.height = CELL_SIZE * BOARD_HEIGHT;
        }
    }
    window.addEventListener('resize', resizeGameCanvas);
    window.addEventListener('orientationchange', resizeGameCanvas);
    window.addEventListener('DOMContentLoaded', resizeGameCanvas);
    // --- Tam ekran butonu kaldırıldı ---
    // window.addEventListener('resize', resizeGameCanvas);
    // --- Oyun başlatıldığında canvas'ı tam ekran boyutla ---
    document.getElementById('startBtn').onclick = startGame;
    document.getElementById('nicknameInput').addEventListener('keydown', function(e) {
        if (e.key === 'Enter') startGame();
    });
    function startGame() {
        // Kullanıcı adını input'tan tekrar al
        const input = document.getElementById('nicknameInput');
        nickname = input.value.trim();
        // Matrix mode kontrolü
        if (nickname && ['matrix','neo','admin'].includes(nickname.toLowerCase())) {
            startMatrixRain();
        } else {
            stopMatrixRain();
        }
        const errorDiv = document.getElementById('ui-error');
        input.classList.remove('error');
        errorDiv.textContent = '';
        if (!nickname) {
            errorDiv.textContent = 'Kullanıcı adı gir!';
            input.classList.add('error');
            return;
        }
        if (nickname.length > 8) {
            errorDiv.textContent = 'Kullanıcı adı en fazla 8 karakter olmalı!';
            input.classList.add('error');
            return;
        }
        
        // Mod seçimi ekranına geç
        document.getElementById('ui').style.display = 'none';
        document.getElementById('mode-ui').style.display = 'flex';
    }
    
    function selectMode() {
        const modeSelection = document.querySelector('.mode-btn.active');
        
        if (!modeSelection) {
            document.getElementById('mode-error').textContent = 'Please select a game mode!';
            return;
        }
        
        currentGameMode = modeSelection.dataset.mode;
        
        if (currentGameMode === 'timeAttack') {
            // Zorluk seçimi ekranına geç
            document.getElementById('mode-ui').style.display = 'none';
            document.getElementById('difficulty-ui').style.display = 'flex';
        } else {
            // Klasik mod için direkt oyunu başlat
            startGameMode();
        }
    }
    
    function selectDifficulty() {
        const difficultySelection = document.querySelector('.difficulty-btn.active');
        
        if (!difficultySelection) {
            document.getElementById('difficulty-error').textContent = 'Please select a difficulty level!';
            return;
        }
        
        currentDifficulty = difficultySelection.dataset.difficulty;
        startGameMode();
    }
    

    

    
    function startGameMode() {
        document.getElementById('mode-ui').style.display = 'none';
        document.getElementById('difficulty-ui').style.display = 'none';
        
        // Loading overlay'i göster
        const loadingOverlay = document.getElementById('loading-overlay');
        loadingOverlay.classList.add('show');
        
        // Oyun container'ını hazırla ama henüz gösterme
        document.getElementById('game-container').style.display = 'flex';
        document.getElementById('top-usernames').style.display = 'flex';
        document.getElementById('main-menu-btn').style.display = 'inline-block';
        started = true;
        currentDirection = null;
        
        // Klasik mod için currentGameMode'u ayarla
        if (!currentGameMode || currentGameMode === 'classic') {
            currentGameMode = 'classic';
        }
        
        // Canvas'ı boyutlandır
        resizeGameCanvas();
        
        // Render loop'u başlat
        startRenderLoop();
        
        // Bağlantıyı kur
        connect();
    }

    // Tam sıfırlama ve ana menüye dönüş
    function resetToMainMenu() {
        // Otomatik yeniden bağlanmayı kapat
        suppressAutoReconnect = true;
        // Sunucuya düzgün ayrıl (disconnect event tetiklenecek)
        try {
            if (socket) {
                socket.disconnect();
            }
        } catch (e) {}

        // Render loop'u durdur ve canvas'ı temizle
        stopRenderLoop();
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Tüm client-side state'i temizle
        gameState = null;
        timeAttackState = null;
        currentGameMode = null;
        currentDifficulty = null;
        started = false;
        readySent = false;
        eliminationTime = null;
        currentDirection = null;
        myId = null;

        // UI temizliği
        document.getElementById('top-usernames').style.display = 'none';
        document.getElementById('top-usernames').innerHTML = '';
        document.getElementById('game-container').style.display = 'none';
        document.getElementById('mode-ui').style.display = 'none';
        document.getElementById('difficulty-ui').style.display = 'none';
        document.getElementById('main-menu-btn').style.display = 'none';

        // Loading overlay sakla
        const loadingOverlay = document.getElementById('loading-overlay');
        loadingOverlay.classList.remove('show');

        // Time Attack özel UI temizliği
        const timeAttackUI = document.getElementById('time-attack-ui');
        if (timeAttackUI) timeAttackUI.remove();
        hideRespawnMessage();
        hideEagleEggScreen();

        // Kullanıcı adı ekranına dön ve input'u temizle
        const input = document.getElementById('nicknameInput');
        if (input) input.value = '';
        nickname = '';
        document.getElementById('ui').style.display = 'flex';

        // Arka plan efektini durdur
        stopMatrixRain();
    }

    // Easter egg: yukarı, sağ, aşağı, aşağı, aşağı kombinasyonu
    const easterEggSequence = ['ArrowUp', 'ArrowRight', 'ArrowDown', 'ArrowDown', 'ArrowDown'];
    let easterEggProgress = 0;
    document.addEventListener('keydown', (e) => {
        if (!started || !socket || socket.disconnected) return;
        if (!myId) return;
        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "w", "W", "a", "A", "s", "S", "d", "D"].includes(e.key)) {
            e.preventDefault();
        }
        if (e.repeat) return; // Sadece ilk basışta çalışsın, basılı tutunca ilerlemesin
        
        // Time Attack modu için
        if (currentGameMode === 'timeAttack') {
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') sendTimeAttackMove('UP');
            else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') sendTimeAttackMove('DOWN');
            else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') sendTimeAttackMove('LEFT');
            else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') sendTimeAttackMove('RIGHT');
            else if (e.key === 'Enter') {
                if (socket && socket.connected) {
                    socket.emit('time_attack_respawn', {client_id: myId});
                    // Canlanma mesajını hemen gizle
                    hideRespawnMessage();
                }
            }

        } else {
            // Klasik mod için
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') sendMove('UP');
            else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') sendMove('DOWN');
            else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') sendMove('LEFT');
            else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') sendMove('RIGHT');
            else if (e.key === 'Enter') {
                hideEagleEggScreen();
                if (gameState && gameState.active && !gameState.active[myId]) {
                    socket.emit('restart', {client_id: myId});
                    // Mesajı hemen gizle
                    const msgDiv = document.getElementById('game-message');
                    msgDiv.style.display = 'none';
                } else if (gameState && gameState.waiting_for_restart) {
                    if (!readySent) {
                        socket.emit('ready', {client_id: myId});
                        readySent = true;
                        // Mesajı hemen güncelle
                        updateRestartButton();
                    }
                }
            }
        }
        
        // Easter egg kontrolü (her iki modda da çalışır)
        if (e.key === easterEggSequence[easterEggProgress]) {
            easterEggProgress++;
            if (easterEggProgress === easterEggSequence.length) {
                // PNG'yi hemen ekrana getir
                showEagleEggScreen();
                // Sunucuya özel mesaj gönder
                if (socket && socket.connected) {
                    socket.emit('easteregg', {client_id: myId});
                }
                easterEggProgress = 0;
            }
        } else {
            easterEggProgress = 0;
        }
    });

    // --- Mesaj gönderme fonksiyonları ---
    function sendMove(dir) {
        if (!myId || !socket || !socket.connected) return;
        // Direkt gönder - hiçbir kontrol yapma
        socket.emit('move', {client_id: myId, direction: dir});
        currentDirection = dir;
    }
    
    // Mod ve zorluk seçimi event listener'ları
    document.addEventListener('DOMContentLoaded', () => {
        // Mod seçimi
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById('modeStartBtn').style.display = 'inline-block';
            });
        });
        
        // Zorluk seçimi
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById('difficultyStartBtn').style.display = 'inline-block';
            });
        });
        
        // Kullanıcı adı ekranı başlat butonu
        document.getElementById('startBtn').addEventListener('click', startGame);
        
        // Mod seçimi başlat butonu
        document.getElementById('modeStartBtn').addEventListener('click', selectMode);
        
        // Zorluk seçimi başlat butonu
        document.getElementById('difficultyStartBtn').addEventListener('click', selectDifficulty);
        
        // Ana Menü butonu
        const mainMenuBtn = document.getElementById('main-menu-btn');
        if (mainMenuBtn) {
            mainMenuBtn.addEventListener('click', resetToMainMenu);
        }

        

    });

    // Eagle easter egg görseli için asset yükle
    assets.eagle = new Image();
    assets.eagle.src = 'assets/Eagle_500kg.png';

    function showEagleEggScreen() {
        let overlay = document.getElementById('eagle-egg-overlay');
        if (!overlay) {
            overlay = document.createElement('div');
            overlay.id = 'eagle-egg-overlay';
            overlay.style.position = 'fixed';
            overlay.style.left = '0';
            overlay.style.top = '0';
            overlay.style.width = '100vw';
            overlay.style.height = '100vh';
            overlay.style.background = 'rgba(0,0,0,0.7)';
            overlay.style.display = 'flex';
            overlay.style.flexDirection = 'column';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '99999';
            document.body.appendChild(overlay);
        }
        overlay.innerHTML = '';
        const img = document.createElement('img');
        img.src = assets.eagle && assets.eagle.src ? assets.eagle.src : 'assets/Eagle_500kg.png';
        img.alt = 'Eagle Easter Egg';
        img.style.width = '220px';
        img.style.maxWidth = '90vw';
        img.style.maxHeight = '90vh';
        img.onerror = function() {
            overlay.innerHTML = '<div style="color:white;font-size:2em;">Eagle PNG yüklenemedi! (' + img.src + ')</div>';
        };
        img.onload = function() {
        };
        overlay.appendChild(img);
        overlay.style.display = 'flex';
        overlay.style.visibility = 'visible';
        overlay.style.opacity = '1';
    }

    // Oyuncu yeniden başlatınca eagle overlay'i kapat
    function hideEagleEggScreen() {
        const overlay = document.getElementById('eagle-egg-overlay');
        if (overlay) overlay.style.display = 'none';
    }

    // Matrix yağmuru için canvas'ı body'nin en başına ekle
    let matrixCanvas = document.getElementById('matrix-bg');
    if (!matrixCanvas) {
        matrixCanvas = document.createElement('canvas');
        matrixCanvas.id = 'matrix-bg';
        matrixCanvas.style.position = 'fixed';
        matrixCanvas.style.left = '0';
        matrixCanvas.style.top = '0';
        matrixCanvas.style.width = '100vw';
        matrixCanvas.style.height = '100vh';
        matrixCanvas.style.pointerEvents = 'none';
        matrixCanvas.style.zIndex = '0'; // EN ARKADA!
        document.body.insertBefore(matrixCanvas, document.body.firstChild);
    }
    // Oyun canvası ve UI elementlerinin z-index'i 1 veya daha yüksek olmalı
    const gameCanvas = document.getElementById('game');
    if (gameCanvas) gameCanvas.style.zIndex = '1';
    const topUsernames = document.getElementById('top-usernames');
    if (topUsernames) topUsernames.style.zIndex = '2';
    const gameContainer = document.getElementById('game-container');
    if (gameContainer) gameContainer.style.zIndex = '2';

    let matrixAnimId = null;
    function startMatrixRain() {
        const c = matrixCanvas;
        const ctx = c.getContext('2d');
        c.width = window.innerWidth;
        c.height = window.innerHeight;
        const letters = '10'; // Sadece 1 ve 0 karakterleri
        const fontSize = 18;
        const columns = Math.floor(c.width / fontSize);
        const drops = Array(columns).fill(1);
        function drawMatrix() {
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            ctx.fillRect(0, 0, c.width, c.height);
            ctx.font = fontSize + 'px monospace';
            ctx.fillStyle = '#0F0';
            for (let i = 0; i < drops.length; i++) {
                const text = letters[Math.floor(Math.random() * letters.length)];
                ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                if (drops[i] * fontSize > c.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }
                drops[i]++;
            }
            matrixAnimId = requestAnimationFrame(drawMatrix);
        }
        drawMatrix();
        window.addEventListener('resize', resizeMatrixCanvas);
        function resizeMatrixCanvas() {
            c.width = window.innerWidth;
            c.height = window.innerHeight;
        }
    }
    function stopMatrixRain() {
        if (matrixAnimId) cancelAnimationFrame(matrixAnimId);
        const ctx = matrixCanvas.getContext('2d');
        ctx.clearRect(0, 0, matrixCanvas.width, matrixCanvas.height);
    }

    // startGame fonksiyonunun başında nickname kontrolüyle animasyonu başlat/durdur
    const origStartGame = startGame;
    startGame = function() {
        if (nickname && ['matrix','neo','admin'].includes(nickname.trim().toLowerCase())) {
            startMatrixRain();
        } else {
            stopMatrixRain();
        }
        origStartGame.apply(this, arguments);
    };

    // Oyun bitince veya sayfa kapanınca animasyonu durdur
    window.addEventListener('beforeunload', stopMatrixRain);

    // Dokunmatik yön tuşları
    function setupTouchControls() {
        const up = document.getElementById('btn-up');
        const down = document.getElementById('btn-down');
        const left = document.getElementById('btn-left');
        const right = document.getElementById('btn-right');
        const restart = document.getElementById('btn-restart');
        if (!up) return;
        
        // Touch kontroller için eagle easter egg kontrolü
        function checkEasterEgg(key) {
            if (key === easterEggSequence[easterEggProgress]) {
                easterEggProgress++;
                if (easterEggProgress === easterEggSequence.length) {
                    // PNG'yi hemen ekrana getir
                    showEagleEggScreen();
                    // Sunucuya özel mesaj gönder
                    if (socket && socket.connected) {
                        socket.emit('easteregg', {client_id: myId});
                    }
                    easterEggProgress = 0;
                }
            } else {
                easterEggProgress = 0;
            }
        }
        
        up.addEventListener('touchstart', e => { 
            e.preventDefault(); 
            checkEasterEgg('ArrowUp');
            if (currentGameMode === 'timeAttack') {
                sendTimeAttackMove('UP');
            } else {
                sendMove('UP');
            }
        });
        down.addEventListener('touchstart', e => { 
            e.preventDefault(); 
            checkEasterEgg('ArrowDown');
            if (currentGameMode === 'timeAttack') {
                sendTimeAttackMove('DOWN');
            } else {
                sendMove('DOWN');
            }
        });
        left.addEventListener('touchstart', e => { 
            e.preventDefault(); 
            checkEasterEgg('ArrowLeft');
            if (currentGameMode === 'timeAttack') {
                sendTimeAttackMove('LEFT');
            } else {
                sendMove('LEFT');
            }
        });
        right.addEventListener('touchstart', e => { 
            e.preventDefault(); 
            checkEasterEgg('ArrowRight');
            if (currentGameMode === 'timeAttack') {
                sendTimeAttackMove('RIGHT');
            } else {
                sendMove('RIGHT');
            }
        });
        if (restart) {
            restart.addEventListener('touchstart', e => {
                e.preventDefault();
                if (myId && gameState && gameState.active && !gameState.active[myId]) {
                    socket.emit('restart', {client_id: myId});
                } else if (gameState && gameState.waiting_for_restart) {
                    if (!readySent) {
                        socket.emit('ready', {client_id: myId});
                        readySent = true;
                    }
                }
            });
        }
        // Masaüstünde görünmesin, mobilde görünsün
        function updateTouchControlsVisibility() {
            const controls = document.getElementById('touch-controls');
            if (window.innerWidth < 900 || /Android|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop/i.test(navigator.userAgent)) {
                controls.style.display = 'flex';
            } else {
                controls.style.display = 'none';
            }
        }
        window.addEventListener('resize', updateTouchControlsVisibility);
        updateTouchControlsVisibility();
    }
    window.addEventListener('DOMContentLoaded', setupTouchControls);

    // Ekran dikeyse uyarı göster
    function checkOrientation() {
        const warning = document.getElementById('rotate-warning');
        if (window.innerWidth < window.innerHeight) {
            warning.style.display = 'flex';
        } else {
            warning.style.display = 'none';
        }
    }
    window.addEventListener('resize', checkOrientation);
    window.addEventListener('orientationchange', checkOrientation);
    window.addEventListener('DOMContentLoaded', checkOrientation);

    // Time Attack fonksiyonları
    function showTimeAttackUI() {
        const existingUI = document.getElementById('time-attack-ui');
        if (existingUI) {
            existingUI.remove();
        }
        
        const ui = document.createElement('div');
        ui.id = 'time-attack-ui';
        ui.innerHTML = `
            <h3>Time Attack</h3>
            <div id="time-display">Time: <span id="time-left">--</span></div>
            <div id="score-display">Score: <span id="score">0</span></div>
            <div id="respawn-display">Respawn: <span id="respawn-count">0</span></div>
            <span id="difficulty-display">Difficulty: --</span>
            <button id="respawn-btn">Respawn</button>
        `;
        document.body.appendChild(ui);
        
        // Render loop'u başlat
        startRenderLoop();
        
        // Respawn button event listener
        document.getElementById('respawn-btn').addEventListener('click', () => {
            if (socket && socket.connected) {
                socket.emit('time_attack_respawn', {client_id: myId});
            }
        });
    }
    
    function drawTimeAttack() {
        if (!timeAttackState) {
            return;
        }
        
        // Canvas'ı tamamen temizle
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Sadece Time Attack için arka plan
        if (assets.bg) {
            const pattern = ctx.createPattern(assets.bg, 'repeat');
            ctx.save();
            ctx.fillStyle = pattern;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.restore();
        } else {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // Yılan
        if (timeAttackState.snake) {
            // Klasik moddaki renk sistemi
            const colorInfo = timeAttackState.color_info || { hex: '#00ff00' };
            const isFrozen = !!(timeAttackState.active_powerups && 
                               timeAttackState.active_powerups[myId] && 
                               timeAttackState.active_powerups[myId].freeze);
            
            // Renk belirleme
            let snakeColor = colorInfo.hex || '#00ff00';
            if (isFrozen) {
                snakeColor = '#888888';  // Donmuşsa gri
            }
            
            for (const [i, seg] of timeAttackState.snake.entries()) {
                const x = seg[0] * CELL_SIZE;
                const y = seg[1] * CELL_SIZE;
                        
                // Baş için özel çizim
                if (i === 0) {
                    ctx.fillStyle = snakeColor;
                ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
                        
                    // Baş için glow efekti
                    if (!isFrozen && colorInfo.effect) {
                        const eff = (typeof COLOR_EFFECTS !== 'undefined') ? COLOR_EFFECTS[colorInfo.effect] : null;
                        if (eff) {
                            ctx.shadowColor = eff.glow;
                            ctx.shadowBlur = 10;
                            ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
                            ctx.shadowBlur = 0;
                        }
                    }
                } else {
                    // Vücut için normal çizim
                        ctx.fillStyle = snakeColor;
                        ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
                    }
                }
            
            // Speed power-up aktifse nebula smoke efekti (Time Attack)
            if (timeAttackState.active_powerups && timeAttackState.active_powerups[myId] && 
                timeAttackState.active_powerups[myId].speed && timeAttackState.snake && timeAttackState.snake.length > 0) {
                const head = timeAttackState.snake[0];
                let smokeX = head[0] * CELL_SIZE + CELL_SIZE / 2;
                let smokeY = head[1] * CELL_SIZE + CELL_SIZE / 2;
                
                // Yılanın hareket yönünü hesapla ve dumanı arkasından çıkar
                if (timeAttackState.snake.length > 1) {
                    const neck = timeAttackState.snake[1];
                    const dx = head[0] - neck[0];
                    const dy = head[1] - neck[1];
                    
                    // Dumanı yılanın arkasından çıkar
                    smokeX = head[0] * CELL_SIZE + CELL_SIZE / 2 - dx * CELL_SIZE * 0.3;
                    smokeY = head[1] * CELL_SIZE + CELL_SIZE / 2 - dy * CELL_SIZE * 0.3;
                }
                
                createSmokeEffect(smokeX, smokeY, 'nebula');
            }
        }
        
        // Trail sistemi (Time Attack için)
        if (timeAttackState.trails && timeAttackState.trails.length > 0) {
            const colorInfo = timeAttackState.color_info || { hex: '#00ff00' };
            const isFrozen = !!(timeAttackState.active_powerups && 
                               timeAttackState.active_powerups[myId] && 
                               timeAttackState.active_powerups[myId].freeze);
            
            // Trail rengi belirleme
            let trailColor = colorInfo.hex || '#00ff00';
            if (isFrozen) {
                trailColor = '#888888';
            } else if (colorInfo.effect && typeof COLOR_EFFECTS !== 'undefined') {
                const eff = COLOR_EFFECTS[colorInfo.effect];
                if (eff) {
                    trailColor = eff.trail;
                }
            }
            
            ctx.globalAlpha = 0.5;
            ctx.fillStyle = hexToRgba(trailColor, 0.5);
            for (const trail of timeAttackState.trails) {
                const x = trail[0] * CELL_SIZE;
                const y = trail[1] * CELL_SIZE;
                ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
            }
            ctx.globalAlpha = 1.0;
        }
        
        // Yemler
        if (timeAttackState.food) {
            for (const food of timeAttackState.food) {
                const [fx, fy] = food;
                const x = fx * CELL_SIZE + CELL_SIZE/2;
                const y = fy * CELL_SIZE + CELL_SIZE/2;
                const radius = CELL_SIZE/2 - 2;
                
                // Rastgele yem şekli (klasik moddaki gibi)
                const foodType = Math.abs(fx + fy) % 4; // 4 farklı yem tipi
                
                switch(foodType) {
                    case 0: // Kırmızı elma
                        ctx.fillStyle = '#ff0000';
                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, 2 * Math.PI);
                        ctx.fill();
                        // Elma sapı
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(x - 1, y - radius - 2, 2, 3);
                        break;
                        
                    case 1: // Yeşil elma
                        ctx.fillStyle = '#00ff00';
                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, 2 * Math.PI);
                        ctx.fill();
                        // Elma sapı
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(x - 1, y - radius - 2, 2, 3);
                        break;
                        
                    case 2: // Mavi yuvarlak
                        ctx.fillStyle = '#0080ff';
                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, 2 * Math.PI);
                        ctx.fill();
                        break;
                        
                    case 3: // Mor kare
                        ctx.fillStyle = '#8000ff';
                        ctx.fillRect(fx*CELL_SIZE + 2, fy*CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
                        break;
                }
            }
        }
        
        // Altın elma - Sarı parıltılı yuvarlak (Time Attack)
        if (timeAttackState.golden_food) {
            const [gx, gy] = timeAttackState.golden_food;
            const x = gx * CELL_SIZE + CELL_SIZE/2;
            const y = gy * CELL_SIZE + CELL_SIZE/2;
            const radius = CELL_SIZE/2;
            const time = Date.now() * 0.006;
            
            // Dış glow efekti - sarı parıltı
            const glowRadius = radius * 2.0;
            const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, glowRadius);
            glowGradient.addColorStop(0, 'rgba(255, 255, 50, 0.9)');
            glowGradient.addColorStop(0.5, 'rgba(255, 255, 100, 0.5)');
            glowGradient.addColorStop(1, 'rgba(255, 255, 50, 0)');
            
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(x, y, glowRadius, 0, 2 * Math.PI);
            ctx.fill();
            
            // Ana altın elma - gradient sarı daire
            const goldenGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
            goldenGradient.addColorStop(0, 'rgba(255, 255, 100, 1)');
            goldenGradient.addColorStop(0.6, 'rgba(255, 215, 0, 0.95)');
            goldenGradient.addColorStop(1, 'rgba(255, 165, 0, 0.9)');
            
            ctx.fillStyle = goldenGradient;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fill();
            
            // İç parıltı - pulse animasyonu
            const pulse = 0.7 + 0.3 * Math.sin(time * 2.5);
            const innerRadius = radius * 0.7;
            const innerGradient = ctx.createRadialGradient(x, y, 0, x, y, innerRadius);
            innerGradient.addColorStop(0, `rgba(255, 255, 200, ${pulse})`);
            innerGradient.addColorStop(1, 'rgba(255, 255, 150, 0)');
            
            ctx.fillStyle = innerGradient;
            ctx.beginPath();
            ctx.arc(x, y, innerRadius, 0, 2 * Math.PI);
            ctx.fill();
            
            // Kenarlık - parıltılı çizgi
            ctx.strokeStyle = `rgba(255, 255, 220, ${0.9 + 0.1 * Math.sin(time * 3)})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.stroke();
            
            // Dönen parıltı efektleri
            const sparkleCount = 8;
            for (let i = 0; i < sparkleCount; i++) {
                const angle = time * 1.5 + (i * Math.PI * 2 / sparkleCount);
                const sparkleRadius = radius * 1.3;
                const sparkleX = x + Math.cos(angle) * sparkleRadius;
                const sparkleY = y + Math.sin(angle) * sparkleRadius;
                
                ctx.save();
                ctx.globalAlpha = 0.8 * pulse;
                ctx.fillStyle = '#ffff80';
                ctx.beginPath();
                ctx.arc(sparkleX, sparkleY, 2, 0, 2 * Math.PI);
                ctx.fill();
                ctx.restore();
            }
        }
        
        // Engeller
        if (timeAttackState.obstacles) {
            for (const obs of timeAttackState.obstacles) {
                const [ox, oy] = obs.pos;
                const size = CELL_SIZE * 1.5;
                const offset = (size - CELL_SIZE) / 2;
                if (obs.type === 'grass' || obs.type === 'slow') {
                    // Etkileşimli Mavi Sis Efekti (Time Attack)
                    const x = ox * CELL_SIZE + CELL_SIZE/2;
                    const y = oy * CELL_SIZE + CELL_SIZE/2;
                    const size = CELL_SIZE;
                    const time = Date.now() * 0.004;
                    
                    // Yılanın mesafesini hesapla
                    let distance = 999;
                    let intensity = 0.3; // Minimum yoğunluk
                    if (timeAttackState.snake && timeAttackState.snake.length > 0) {
                        const [hx, hy] = timeAttackState.snake[0];
                        distance = Math.abs(hx - ox) + Math.abs(hy - oy);
                        
                        // Mesafeye göre yoğunluk hesapla (yakın = yoğun)
                        if (distance <= 3) {
                            intensity = 1.0; // Tam yoğunluk
                        } else if (distance <= 6) {
                            intensity = 0.3 + 0.7 * (1 - (distance - 3) / 3);
                        }
                    }
                    
                    // Dış glow efekti - mavi sis
                    const glowSize = size * 2.5 * intensity;
                    const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, glowSize/2);
                    glowGradient.addColorStop(0, `rgba(100, 150, 255, ${0.9 * intensity})`);
                    glowGradient.addColorStop(0.3, `rgba(80, 120, 220, ${0.7 * intensity})`);
                    glowGradient.addColorStop(0.6, `rgba(60, 100, 200, ${0.5 * intensity})`);
                    glowGradient.addColorStop(1, 'rgba(40, 80, 180, 0)');
                    
                    ctx.fillStyle = glowGradient;
                    ctx.fillRect(x - glowSize/4, y - glowSize/4, size + glowSize/2, size + glowSize/2);
                    
                    // Ana sis - organik mavi sis şekli
                    ctx.save();
                    ctx.globalAlpha = 0.8 * intensity;
                    
                    // Sis parçacıkları - rastgele dağılım
                    const particleCount = Math.floor(15 * intensity);
                    for (let i = 0; i < particleCount; i++) {
                        const particleX = x + (Math.random() - 0.5) * size * 1.2;
                        const particleY = y + (Math.random() - 0.5) * size * 1.2;
                        const particleSize = Math.random() * 4 + 2;
                        const particleAlpha = Math.random() * 0.6 + 0.2;
                        
                        ctx.fillStyle = `rgba(120, 180, 255, ${particleAlpha * intensity})`;
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, particleSize, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    
                    // Sis bulutları - daha büyük parçacıklar
                    const cloudCount = Math.floor(8 * intensity);
                    for (let i = 0; i < cloudCount; i++) {
                        const cloudX = x + (Math.random() - 0.5) * size * 0.8;
                        const cloudY = y + (Math.random() - 0.5) * size * 0.8;
                        const cloudSize = Math.random() * 8 + 4;
                        const cloudAlpha = Math.random() * 0.4 + 0.3;
                        
                        ctx.fillStyle = `rgba(100, 150, 230, ${cloudAlpha * intensity})`;
                        ctx.beginPath();
                        ctx.arc(cloudX, cloudY, cloudSize, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                    
                    // Sis hareketi - yukarı doğru yükselen efekt
                    const riseEffect = Math.sin(time * 0.5) * 0.3;
                    ctx.save();
                    ctx.globalAlpha = 0.6 * intensity;
                    
                    for (let i = 0; i < 5; i++) {
                        const riseX = x + (Math.random() - 0.5) * size * 0.6;
                        const riseY = y + (Math.random() - 0.5) * size * 0.6 + riseEffect * 10;
                        const riseSize = Math.random() * 6 + 3;
                        
                        ctx.fillStyle = `rgba(80, 120, 200, ${0.4 * intensity})`;
                        ctx.beginPath();
                        ctx.arc(riseX, riseY, riseSize, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                    
                    // Dönen manyetik parçacıklar (yakın mesafede)
                    if (distance <= 4) {
                        const magneticCount = Math.floor(6 * intensity);
                        for (let i = 0; i < magneticCount; i++) {
                            const angle = time * 0.8 + (i * Math.PI * 2 / magneticCount);
                            const magneticRadius = size * 0.7;
                            const magneticX = x + Math.cos(angle) * magneticRadius;
                            const magneticY = y + Math.sin(angle) * magneticRadius;
                            
                            ctx.save();
                            ctx.globalAlpha = 0.8 * intensity;
                            ctx.fillStyle = '#80b0ff';
                            ctx.beginPath();
                            ctx.arc(magneticX, magneticY, 3, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.restore();
                        }
                    }
                    
                    // Çekim efekti - yılan çok yakınsa
                    if (distance <= 2) {
                        const attractionSize = size * 2;
                        const attractionGradient = ctx.createRadialGradient(x, y, 0, x, y, attractionSize);
                        attractionGradient.addColorStop(0, `rgba(100, 150, 255, ${0.3 * intensity})`);
                        attractionGradient.addColorStop(1, 'rgba(100, 150, 255, 0)');
                        
                        ctx.fillStyle = attractionGradient;
                        ctx.fillRect(x - attractionSize/2, y - attractionSize/2, attractionSize, attractionSize);
                    }
                } else if (obs.type === 'enemy' && assets.enemy) {
                    ctx.drawImage(assets.enemy, ox*CELL_SIZE - offset, oy*CELL_SIZE - offset, size, size);
                } else if (obs.type === 'hidden_wall') {
                    // Gizli duvarlar yılanın başının 8 blok yakınında görünür (daha uzak mesafe)
                    let show = false;
                    let distance = 0;
                    if (timeAttackState.snake && timeAttackState.snake.length > 0) {
                        const [hx, hy] = timeAttackState.snake[0];
                        distance = Math.abs(hx - ox) + Math.abs(hy - oy);
                        if (distance <= 8) show = true; // Mesafeyi 4'ten 8'e çıkardık
                    }
                    if (show) {
                        const x = ox * CELL_SIZE;
                        const y = oy * CELL_SIZE;
                        const size = CELL_SIZE;
                        const time = Date.now() * 0.003; // Daha yavaş animasyon
                        
                        // Kademeli görünürlük (mesafeye göre) - daha yumuşak geçiş
                        const visibility = Math.max(0.65, 1 - (distance / 8)); // Başlangıç parlaklığını artırdık, mesafeyi uzattık
                        
                        // ÇOK DAHA PARLAK Glow efekti
                        const glowSize = size * 3.5; // Glow boyutunu artırdık
                        const glowGradient = ctx.createRadialGradient(
                            x + size/2, y + size/2, 0,
                            x + size/2, y + size/2, glowSize/2
                        );
                        glowGradient.addColorStop(0, `rgba(255, 165, 0, ${1.0 * visibility})`); // Turuncu
                        glowGradient.addColorStop(0.2, `rgba(255, 140, 0, ${0.9 * visibility})`);
                        glowGradient.addColorStop(0.4, `rgba(255, 120, 0, ${0.7 * visibility})`);
                        glowGradient.addColorStop(0.7, `rgba(255, 100, 0, ${0.4 * visibility})`);
                        glowGradient.addColorStop(1, 'rgba(255, 80, 0, 0)');
                        
                        ctx.fillStyle = glowGradient;
                        ctx.fillRect(x - glowSize/3, y - glowSize/3, size + glowSize/1.5, size + glowSize/1.5);
                        
                        // Ana duvar - ÇOK DAHA PARLAK gradient
                        const wallGradient = ctx.createLinearGradient(x, y, x + size, y + size);
                        wallGradient.addColorStop(0, `rgba(255, 165, 0, ${1.0 * visibility})`); // Turuncu
                        wallGradient.addColorStop(0.3, `rgba(255, 140, 0, ${0.98 * visibility})`);
                        wallGradient.addColorStop(0.7, `rgba(255, 120, 0, ${0.98 * visibility})`);
                        wallGradient.addColorStop(1, `rgba(255, 100, 0, ${1.0 * visibility})`);
                        
                        ctx.fillStyle = wallGradient;
                        ctx.fillRect(x, y, size, size);
                        
                        // ÇOK DAHA PARLAK Kenarlık - pulse animasyonu
                        const borderAlpha = 0.95 + 0.05 * Math.sin(time * 2); // Daha hızlı pulse
                        ctx.strokeStyle = `rgba(255, 255, 255, ${borderAlpha * visibility})`; // Beyaz kenarlık
                        ctx.lineWidth = 5; // Daha kalın kenarlık
                        ctx.strokeRect(x + 1, y + 1, size - 2, size - 2);
                        
                        // İkinci kenarlık - dış glow efekti
                        ctx.strokeStyle = `rgba(255, 200, 100, ${0.6 * visibility})`; // Turuncu ton
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x - 1, y - 1, size + 2, size + 2);
                        
                        // İç detay - daha parlak çapraz çizgiler
                        ctx.strokeStyle = `rgba(255, 255, 255, ${0.7 * visibility})`; // Daha parlak
                        ctx.lineWidth = 2; // Daha kalın
                        ctx.beginPath();
                        ctx.moveTo(x + 4, y + 4);
                        ctx.lineTo(x + size - 4, y + size - 4);
                        ctx.moveTo(x + size - 4, y + 4);
                        ctx.lineTo(x + 4, y + size - 4);
                        ctx.stroke();
                        
                        // Merkez nokta - dikkat çekici
                        ctx.fillStyle = `rgba(255, 255, 255, ${0.9 * visibility})`;
                        ctx.beginPath();
                        ctx.arc(x + size/2, y + size/2, 3, 0, 2 * Math.PI);
                        ctx.fill();
                        
                        // Uyarı işareti - mesafe 3'ten azsa
                        if (distance <= 3) {
                            ctx.fillStyle = `rgba(255, 255, 0, ${0.8 * visibility})`; // Sarı uyarı
                            ctx.font = 'bold 12px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('!', x + size/2, y + size/2 + 4);
                        }
                    }
                }
            }
        }
        
        // Portallar
        if (timeAttackState.portals) {
            for (const portal of timeAttackState.portals) {
                const [px1, py1] = portal[0];
                const [px2, py2] = portal[1];
                
                // Portal A
                ctx.fillStyle = 'rgba(255, 0, 255, 0.7)';
                ctx.beginPath();
                ctx.arc(px1*CELL_SIZE + CELL_SIZE/2, py1*CELL_SIZE + CELL_SIZE/2, CELL_SIZE/2, 0, 2*Math.PI);
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 0, 255, 1)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Portal B
                ctx.fillStyle = 'rgba(0, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.arc(px2*CELL_SIZE + CELL_SIZE/2, py2*CELL_SIZE + CELL_SIZE/2, CELL_SIZE/2, 0, 2*Math.PI);
                ctx.fill();
                ctx.strokeStyle = 'rgba(0, 255, 255, 1)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }
        
        // Power-up'lar
        if (timeAttackState.powerups) {
            for (const powerup of timeAttackState.powerups) {
                const [px, py] = powerup.pos;
                const powerupColors = {
                    'shield': '#000',      // Siyah
                    'speed': '#00f',       // Mavi
                    'reverse': '#fff',     // Beyaz
                    'magnet': '#800080',   // Mor
                    'freeze': '#00ffff',   // Camgöbeği
                    'trail': '#ff6600'     // Turuncu
                };
                
                // Power-up yuvarlak arka planı
                ctx.beginPath();
                ctx.arc(px*CELL_SIZE + CELL_SIZE/2, py*CELL_SIZE + CELL_SIZE/2, CELL_SIZE/2 - 2, 0, 2*Math.PI);
                ctx.fillStyle = powerupColors[powerup.type] || '#00f';
                ctx.fill();
                
                // Power-up yuvarlak kenarlığı
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Power-up tipini yaz
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(powerup.type.charAt(0).toUpperCase(), 
                           px*CELL_SIZE + CELL_SIZE/2, 
                           py*CELL_SIZE + CELL_SIZE/2);
                
                // Yanıp sönen efekt - yuvarlak
                const time = Date.now() / 1000;
                const alpha = 0.5 + 0.5 * Math.sin(time * 3);
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(px*CELL_SIZE + CELL_SIZE/2, py*CELL_SIZE + CELL_SIZE/2, CELL_SIZE/3, 0, 2*Math.PI);
                ctx.fillStyle = '#fff';
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }
        
        updateTimeAttackUI();
    }
    
    function updateTimeAttackUI() {
        if (!timeAttackState) return;
        
        const timeLeft = document.getElementById('time-left');
        const score = document.getElementById('score');
        const respawnCount = document.getElementById('respawn-count');
        const difficultyDisplay = document.getElementById('difficulty-display');
        
        if (timeLeft) timeLeft.textContent = `${Math.floor(timeAttackState.time_left)}s`;
        if (score) score.textContent = timeAttackState.score;
        if (respawnCount) respawnCount.textContent = timeAttackState.respawn_count;
        if (difficultyDisplay) {
            const difficultyNames = {
                'easy': 'Easy',
                'medium': 'Medium',
                'hard': 'Hard'
            };
            difficultyDisplay.textContent = `Difficulty: ${difficultyNames[timeAttackState.difficulty] || '--'}`;
        }
        
        // Power-up efektlerini göster (klasik moddaki gibi)
        if (timeAttackState.active_powerups && timeAttackState.active_powerups[myId]) {
            const powerups = timeAttackState.active_powerups[myId];
            let effectText = '';
            
            if (powerups.shield) effectText += '🛡️ Shield ';
            if (powerups.speed) effectText += '⚡ Speed ';
            if (powerups.reverse) effectText += '🔄 Reverse ';
            if (powerups.magnet) effectText += '🧲 Magnet ';
            if (powerups.freeze) effectText += '❄️ Freeze ';
            if (powerups.trail) effectText += '🌊 Trail ';
            
            if (effectText) {
                // Power-up efekt mesajını göster
                const effectDiv = document.getElementById('powerup-effect') || createPowerupEffectDiv();
                effectDiv.textContent = effectText;
                effectDiv.style.display = 'block';
            }
        } else {
            // Power-up efekti yoksa gizle
            const effectDiv = document.getElementById('powerup-effect');
            if (effectDiv) effectDiv.style.display = 'none';
        }
        
        // Show respawn message if game is paused
        if (!timeAttackState.game_active) {
            // Show result if time is up
            if (timeAttackState.time_left <= 0) {
                showTimeAttackResult();
            } else {
                // Snake eliminated, show respawn message
                showRespawnMessage();
            }
        }
    }
    
    function createPowerupEffectDiv() {
        const div = document.createElement('div');
        div.id = 'powerup-effect';
        div.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: #fff;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 16px;
            font-weight: bold;
            z-index: 1000;
            display: none;
        `;
        document.body.appendChild(div);
        return div;
    }
    
    function showRespawnMessage() {
        // Don't show if respawn message already exists
        if (document.getElementById('respawn-message')) return;
        
        const message = document.createElement('div');
        message.id = 'respawn-message';
        message.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: #fff;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 1000;
            font-size: 18px;
        `;
        
        message.innerHTML = `
            <h3>Snake Eliminated!</h3>
            <p>Press <strong>ENTER</strong> to respawn</p>
            <p>Time Left: ${Math.floor(timeAttackState.time_left)}s</p>
        `;
        
        document.body.appendChild(message);
    }
    
    function hideRespawnMessage() {
        const message = document.getElementById('respawn-message');
        if (message) {
            message.remove();
        }
    }
    
    function showTimeAttackResult() {
        // Canlanma mesajını gizle
        hideRespawnMessage();
        
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        `;
        
        modal.innerHTML = `
            <div style="background: #333; padding: 30px; border-radius: 15px; text-align: center; color: #fff;">
                <h2>TIME'S UP!</h2>
                <p>Final Score: ${timeAttackState.score}</p>
                <p>High Score: ${timeAttackState.high_score}</p>
                <button id="play-again-btn" style="margin: 10px; padding: 10px 20px; background: #4caf50; border: none; border-radius: 5px; color: #fff; cursor: pointer;">Play Again</button>
                <button id="back-to-menu-btn" style="margin: 10px; padding: 10px 20px; background: #666; border: none; border-radius: 5px; color: #fff; cursor: pointer;">Main Menu</button>
            </div>
        `;
        
        document.body.appendChild(modal);
        
        document.getElementById('play-again-btn').addEventListener('click', () => {
            modal.remove();
            // Start new Time Attack game
            if (socket && socket.connected) {
                socket.emit('start_time_attack', {client_id: myId, difficulty: currentDifficulty});
            }
        });
        
        document.getElementById('back-to-menu-btn').addEventListener('click', () => {
            modal.remove();
            resetToMainMenu();
        });
    }
    
    function sendTimeAttackMove(direction) {
        if (socket && socket.connected) {
            socket.emit('time_attack_move', {client_id: myId, direction: direction});
        }
    }
    
    // Show/hide restart button when game state updates
    function updateRestartButton() {
        const restart = document.getElementById('btn-restart');
        if (!restart) return;
        if (myId && gameState && gameState.active && !gameState.active[myId]) {
            restart.style.display = 'inline-flex';
        } else if (gameState && gameState.waiting_for_restart) {
            restart.style.display = 'inline-flex';
        } else {
            restart.style.display = 'none';
        }
    }

    // --- Start ---
    loadAssets(() => {
        resizeGameCanvas();
    });

    // --- Tam ekran fonksiyonu ---
    // (Kaldırıldı)

    // Particle sistemi için değişkenler
    let particles = [];
    
    // Particle sınıfı
    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 4;
            this.vy = (Math.random() - 0.5) * 4;
            this.life = 1.0;
            this.decay = 0.02;
            this.color = color;
            this.size = Math.random() * 3 + 1;
        }
        
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life -= this.decay;
            this.size *= 0.98;
        }
        
        draw(ctx) {
            if (this.life <= 0) return;
            
            ctx.save();
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
        }
    }
    
    // Create particles when snake moves
    function createSnakeParticles(snake, color) {
        if (!snake || snake.length === 0) return;
        
        const head = snake[0];
        const headX = head[0] * CELL_SIZE + CELL_SIZE / 2;
        const headY = head[1] * CELL_SIZE + CELL_SIZE / 2;
        
        // Create particle every 3 frames
        if (Math.random() < 0.3) {
            for (let i = 0; i < 2; i++) {
                particles.push(new Particle(headX, headY, color));
            }
        }
    }
    
    // Update and draw particles
    function updateAndDrawParticles(ctx) {
        particles = particles.filter(particle => particle.life > 0);
        
        for (const particle of particles) {
            particle.update();
            particle.draw(ctx);
        }
    }

    // Gradient and glow effects
    function drawSnakeWithEffects(ctx, snake, color, isMySnake = false) {
        if (!snake || snake.length === 0) return;
        
        // Glow effect (only for our own snake)
        if (isMySnake) {
            ctx.save();
            ctx.shadowColor = color;
            ctx.shadowBlur = 15;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }
        
        // Gradient efekti
        for (let i = 0; i < snake.length; i++) {
            const seg = snake[i];
            const x = seg[0] * CELL_SIZE;
            const y = seg[1] * CELL_SIZE;
            
            // Gradient oluştur (baştan kuyruğa doğru)
            const gradient = ctx.createLinearGradient(x, y, x + CELL_SIZE, y + CELL_SIZE);
            const alpha = 1 - (i / snake.length) * 0.5; // Kuyruğa doğru şeffaflık
            
            if (isMySnake) {
                gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                gradient.addColorStop(0.5, color);
                gradient.addColorStop(1, `rgba(0, 255, 0, ${alpha})`);
            } else {
                gradient.addColorStop(0, color);
                gradient.addColorStop(1, `rgba(255, 255, 0, ${alpha})`);
            }
            
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
            
            // Baş için özel efekt
            if (i === 0) {
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(x + CELL_SIZE/2, y + CELL_SIZE/2, CELL_SIZE/4, 0, 2*Math.PI);
                ctx.fill();
            }
        }
        
        if (isMySnake) {
            ctx.restore();
        }
    }

    // Animated power-up effects
    function drawAnimatedPowerup(ctx, powerup, time) {
        const [x, y] = powerup.pos;
        const centerX = x * CELL_SIZE + CELL_SIZE / 2;
        const centerY = y * CELL_SIZE + CELL_SIZE / 2;
        
        // Power-up colors - brighter and more visible
        const powerupColors = {
            'speed': '#0066ff',
            'shield': '#ff6600',
            'invisible': '#ffff00',
            'reverse': '#ff0066',
            'freeze': '#00ffff',
            'giant': '#ff9900',
            'magnet': '#cc00cc',
            'trail': '#00ffcc'
        };
        
        const color = powerupColors[powerup.type] || '#ff0000';
        
        // Pulsing effect
        const pulse = 0.5 + 0.5 * Math.sin(time * 5);
        const size = CELL_SIZE * (0.8 + pulse * 0.4);
        
        // Dış halka - daha görünür
        ctx.save();
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(centerX, centerY, size, 0, 2 * Math.PI);
        ctx.fill();
        ctx.restore();
        
        // İç halka - daha görünür
        ctx.save();
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(centerX, centerY, size * 0.6, 0, 2 * Math.PI);
        ctx.fill();
        ctx.restore();
        
        // Merkez - daha büyük
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(centerX, centerY, CELL_SIZE / 2.5, 0, 2 * Math.PI);
        ctx.fill();
        
        // Dönen halkalar - daha görünür
        const rotation = time * 2;
        for (let i = 0; i < 3; i++) {
            const angle = rotation + (i * Math.PI * 2 / 3);
            const ringX = centerX + Math.cos(angle) * CELL_SIZE * 0.8;
            const ringY = centerY + Math.sin(angle) * CELL_SIZE * 0.8;
            
            ctx.save();
            ctx.globalAlpha = 0.8;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(ringX, ringY, 4, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
        }
        
        // Power-up tipini gösteren yazı
        ctx.save();
        ctx.fillStyle = '#ffffff';
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.font = 'bold 10px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.strokeText(powerup.type.toUpperCase(), centerX, centerY);
        ctx.fillText(powerup.type.toUpperCase(), centerX, centerY);
        ctx.restore();
        
        // Dış border - daha görünür hale getirmek için
        ctx.save();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(centerX, centerY, CELL_SIZE / 2 + 2, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.restore();
    }

    // Yem yeme patlama efekti
    let explosionParticles = [];
    
    class ExplosionParticle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 8;
            this.vy = (Math.random() - 0.5) * 8;
            this.life = 1.0;
            this.decay = 0.05;
            this.color = color;
            this.size = Math.random() * 6 + 3;
        }
        
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life -= this.decay;
            this.size *= 0.95;
        }
        
        draw(ctx) {
            if (this.life <= 0) return;
            
            ctx.save();
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
        }
    }
    
    function createExplosion(x, y, color) {
        for (let i = 0; i < 15; i++) {
            explosionParticles.push(new ExplosionParticle(x, y, color));
        }
    }
    
    function updateAndDrawExplosions(ctx) {
        explosionParticles = explosionParticles.filter(particle => particle.life > 0);
        
        for (const particle of explosionParticles) {
            particle.update();
            particle.draw(ctx);
        }
    }

    // Dalga efektleri
    function drawWaveEffect(ctx, time) {
        const waveCount = 3;
        const waveSpeed = 0.5;
        const waveAmplitude = 2;
        
        ctx.save();
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        
        for (let i = 0; i < waveCount; i++) {
            ctx.beginPath();
            
            for (let x = 0; x < canvas.width; x += 5) {
                const waveOffset = (time * waveSpeed + i * Math.PI * 2 / waveCount) * 0.01;
                const y = canvas.height / 2 + Math.sin(x * 0.02 + waveOffset) * waveAmplitude;
                
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
        }
        
        ctx.restore();
    }

    // Smoke efekti sistemi
    let smokeParticles = [];
    
    // Shield Aura efekti sistemi
    let shieldAuras = [];
    
    class ShieldAura {
        constructor(x, y, playerId) {
            this.x = x;
            this.y = y;
            this.playerId = playerId;
            this.rotation = 0;
            this.rotationSpeed = 0.05;
            this.radius = CELL_SIZE * 1.5;
            this.ringCount = 3;
            this.pulsePhase = 0;
            this.pulseSpeed = 0.1;
        }
        
        update() {
            this.rotation += this.rotationSpeed;
            this.pulsePhase += this.pulseSpeed;
        }
        
        draw(ctx) {
            ctx.save();
            
            // Aura merkezi
            const centerX = this.x + CELL_SIZE / 2;
            const centerY = this.y + CELL_SIZE / 2;
            
            // Pulse efekti
            const pulse = 0.8 + 0.2 * Math.sin(this.pulsePhase);
            
            // Çoklu halka efekti
            for (let i = 0; i < this.ringCount; i++) {
                const ringRadius = this.radius + i * 8;
                const ringAlpha = (0.6 - i * 0.15) * pulse;
                const ringRotation = this.rotation + i * 0.5;
                
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(ringRotation);
                
                // Dış halka (koruyucu)
                ctx.strokeStyle = `rgba(0, 255, 255, ${ringAlpha})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, ringRadius, 0, 2 * Math.PI);
                ctx.stroke();
                
                // İç halka (enerji)
                ctx.strokeStyle = `rgba(0, 150, 255, ${ringAlpha * 0.7})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, ringRadius - 4, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Koruyucu noktalar
                const dotCount = 8;
                for (let j = 0; j < dotCount; j++) {
                    const angle = (j / dotCount) * 2 * Math.PI;
                    const dotX = Math.cos(angle) * ringRadius;
                    const dotY = Math.sin(angle) * ringRadius;
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${ringAlpha})`;
                    ctx.beginPath();
                    ctx.arc(dotX, dotY, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                ctx.restore();
            }
            
            // Merkez enerji efekti
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(-this.rotation * 0.5);
            
            const centerRadius = CELL_SIZE * 0.3;
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, centerRadius);
            gradient.addColorStop(0, 'rgba(0, 255, 255, 0.8)');
            gradient.addColorStop(0.5, 'rgba(0, 150, 255, 0.4)');
            gradient.addColorStop(1, 'rgba(0, 100, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, 0, centerRadius, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.restore();
            ctx.restore();
        }
    }
    
    function createShieldAura(x, y, playerId) {
        // Eğer bu oyuncu için zaten aura varsa, güncelle
        const existingAura = shieldAuras.find(aura => aura.playerId === playerId);
        if (existingAura) {
            existingAura.x = x;
            existingAura.y = y;
        } else {
            shieldAuras.push(new ShieldAura(x, y, playerId));
        }
    }
    
    function updateAndDrawShieldAuras(ctx) {
        for (const aura of shieldAuras) {
            aura.update();
            aura.draw(ctx);
        }
    }
    
    function removeShieldAura(playerId) {
        shieldAuras = shieldAuras.filter(aura => aura.playerId !== playerId);
    }
    
    class SmokeParticle {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 2;
            this.vy = (Math.random() - 0.5) * 2;
            this.life = 1.0;
            this.decay = 0.02;
            this.size = Math.random() * 8 + 4;
            this.opacity = 0.7;
        }
        
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life -= this.decay;
            this.size *= 1.02; // Smoke büyür
            this.opacity *= 0.98;
        }
        
        draw(ctx) {
            if (this.life <= 0) return;
            
            ctx.save();
            ctx.globalAlpha = this.opacity * this.life;
            ctx.fillStyle = 'rgba(100, 100, 100, 0.8)';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI);
            ctx.fill();
            ctx.restore();
        }
    }
    
    class NebulaSmokeParticle {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.vx = (Math.random() - 0.5) * 1.5; // Daha yavaş hareket
            this.vy = (Math.random() - 0.5) * 1.5;
            this.life = 0.8; // Daha kısa yaşam süresi
            this.decay = 0.035; // Daha hızlı yok olma
            this.size = Math.random() * 8 + 4; // Daha küçük boyut
            this.opacity = 0.5; // Daha düşük opaklık
            
            // Nebula renkleri - daha yumuşak tonlar
            this.colors = [
                '#8B5CF6', // Mor
                '#7C3AED', // Koyu mor
                '#A855F7', // Açık mor
                '#EC4899', // Pembe
                '#F59E8B', // Mercan
                '#6B46C1', // Lavanta
                '#9F7AEA', // Açık lavanta
                '#C084FC'  // Çok açık mor
            ];
            this.color = this.colors[Math.floor(Math.random() * this.colors.length)];
            this.pulseSpeed = Math.random() * 0.05 + 0.02; // Daha yavaş pulse
            this.pulsePhase = Math.random() * Math.PI * 2;
        }
        
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life -= this.decay;
            this.size *= 1.02; // Daha yavaş büyüme
            this.opacity *= 0.98; // Daha yavaş solma
            this.pulsePhase += this.pulseSpeed;
        }
        
        draw(ctx) {
            if (this.life <= 0) return;
            
            ctx.save();
            
            // Pulse efekti
            const pulse = 0.9 + 0.1 * Math.sin(this.pulsePhase);
            const alpha = this.opacity * this.life * pulse;
            
            // Hafif glow efekti
            ctx.shadowColor = this.color;
            ctx.shadowBlur = 8; // Daha az blur
            
            // Ana parçacık
            ctx.globalAlpha = alpha;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, 2 * Math.PI);
            ctx.fill();
            
            // İç parçacık (daha az parlak)
            ctx.globalAlpha = alpha * 0.4;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size * 0.7, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            ctx.restore();
        }
    }
    
    function createSmokeEffect(x, y, type = 'normal') {
        if (type === 'nebula') {
            // Nebula duman efekti - daha fazla parçacık
            for (let i = 0; i < 8; i++) {
                smokeParticles.push(new NebulaSmokeParticle(x, y));
            }
        } else {
            // Normal duman efekti
        for (let i = 0; i < 3; i++) {
            smokeParticles.push(new SmokeParticle(x, y));
            }
        }
    }
    
    function updateAndDrawSmoke(ctx) {
        smokeParticles = smokeParticles.filter(particle => particle.life > 0);
        
        for (const particle of smokeParticles) {
            particle.update();
            particle.draw(ctx);
        }
    }

    // Renk bazlı efekt sistemi
    const COLOR_EFFECTS = {
        "nature": {
            name: "Doğa",
            particles: "leaf",
            glow: "#00ff40",
            trail: "#00ff00"
        },
        "fire": {
            name: "Ateş", 
            particles: "fire",
            glow: "#ffaa00",
            trail: "#ff6600"
        },
        "ice": {
            name: "Buz",
            particles: "ice",
            glow: "#00ffff", 
            trail: "#00ccff"
        },
        "magic": {
            name: "Sihir",
            particles: "magic",
            glow: "#ff00ff",
            trail: "#cc00ff"
        },
        "energy": {
            name: "Enerji",
            particles: "energy", 
            glow: "#ff6600",
            trail: "#ff4400"
        },
        "cosmic": {
            name: "Kozmik",
            particles: "star",
            glow: "#6600ff",
            trail: "#4400ff"
        },
        "blood": {
            name: "Kan",
            particles: "blood",
            glow: "#ff0000",
            trail: "#cc0000"
        },
        "water": {
            name: "Su",
            particles: "water",
            glow: "#0080ff",
            trail: "#0066cc"
        },

        "gold": {
            name: "Altın",
            particles: "gold",
            glow: "#ffd700",
            trail: "#ffcc00"
        },
        "metal": {
            name: "Metal",
            particles: "metal",
            glow: "#c0c0c0",
            trail: "#a0a0a0"
        },
        "neon": {
            name: "Neon",
            particles: "neon",
            glow: "#39ff14",
            trail: "#00ff00"
        }
    };

    // Renk bazlı parçacık sınıfları
    class LeafParticle extends Particle {
        constructor(x, y, color) {
            super(x, y, color);
            this.rotation = Math.random() * Math.PI * 2;
            this.rotationSpeed = (Math.random() - 0.5) * 0.2;
            this.size = Math.random() * 4 + 2;
        }
        
        update() {
            super.update();
            this.rotation += this.rotationSpeed;
        }
        
        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.globalAlpha = this.life / this.maxLife;
            
            // Yaprak şekli
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.ellipse(0, 0, this.size, this.size/2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
    }

    class FireParticle extends Particle {
        constructor(x, y, color) {
            super(x, y, color);
            this.size = Math.random() * 6 + 3;
            this.flicker = 0;
        }
        
        update() {
            super.update();
            this.flicker = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
        }
        
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = (this.life / this.maxLife) * this.flicker;
            
            // Ateş efekti
            const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
            gradient.addColorStop(0, '#ffff00');
            gradient.addColorStop(0.5, this.color);
            gradient.addColorStop(1, 'transparent');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
    }

    class IceParticle extends Particle {
        constructor(x, y, color) {
            super(x, y, color);
            this.size = Math.random() * 4 + 2;
            this.rotation = Math.random() * Math.PI * 2;
        }
        
        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.globalAlpha = this.life / this.maxLife;
            
            // Buz kristali
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI) / 3;
                const x = Math.cos(angle) * this.size;
                const y = Math.sin(angle) * this.size;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.stroke();
            
            ctx.restore();
        }
    }

    class MagicParticle extends Particle {
        constructor(x, y, color) {
            super(x, y, color);
            this.size = Math.random() * 5 + 3;
            this.rotation = 0;
        }
        
        update() {
            super.update();
            this.rotation += 0.1;
        }
        
        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.globalAlpha = this.life / this.maxLife;
            
            // Büyü sembolü
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, this.size, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(-this.size, 0);
            ctx.lineTo(this.size, 0);
            ctx.moveTo(0, -this.size);
            ctx.lineTo(0, this.size);
            ctx.stroke();
            
            ctx.restore();
        }
    }

    class StarParticle extends Particle {
        constructor(x, y, color) {
            super(x, y, color);
            this.size = Math.random() * 4 + 2;
            this.rotation = Math.random() * Math.PI * 2;
            this.twinkle = Math.random();
        }
        
        update() {
            super.update();
            this.twinkle = Math.sin(Date.now() * 0.005 + this.rotation) * 0.5 + 0.5;
        }
        
        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.rotation);
            ctx.globalAlpha = (this.life / this.maxLife) * this.twinkle;
            
            // Yıldız şekli
            ctx.fillStyle = this.color;
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * Math.PI * 2) / 5 - Math.PI / 2;
                const x = Math.cos(angle) * this.size;
                const y = Math.sin(angle) * this.size;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }
    }



    // Renk bazlı parçacık oluşturucu
    function createColorBasedParticles(snake, colorInfo) {
        if (!snake || snake.length === 0 || !colorInfo) return;
        
        const head = snake[0];
        const headX = head[0] * CELL_SIZE + CELL_SIZE / 2;
        const headY = head[1] * CELL_SIZE + CELL_SIZE / 2;
        
        // Her 3 frame'de bir particle oluştur
        if (Math.random() < 0.3) {
            const effect = COLOR_EFFECTS[colorInfo.effect];
            if (!effect) return;
            
            for (let i = 0; i < 2; i++) {
                let particle;
                switch (colorInfo.effect) {
                    case "nature":
                        particle = new LeafParticle(headX, headY, effect.trail);
                        break;
                    case "fire":
                        particle = new FireParticle(headX, headY, effect.trail);
                        break;
                    case "ice":
                        particle = new IceParticle(headX, headY, effect.trail);
                        break;
                    case "magic":
                        particle = new MagicParticle(headX, headY, effect.trail);
                        break;
                    case "cosmic":
                        particle = new StarParticle(headX, headY, effect.trail);
                        break;

                    default:
                        particle = new Particle(headX, headY, effect.trail);
                }
                particles.push(particle);
            }
        }
    }

    // Renk bazlı yılan çizimi
    function drawSnakeWithColorEffects(ctx, snake, colorInfo, isMySnake = false) {
        if (!snake || snake.length === 0 || !colorInfo) return;
        
        const effect = COLOR_EFFECTS[colorInfo.effect];
        if (!effect) return;
        
        // Glow efekti (sadece kendi yılanımız için)
        if (isMySnake) {
            ctx.save();
            ctx.shadowColor = effect.glow;
            ctx.shadowBlur = 15;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }
        
        // Gradient efekti
        for (let i = 0; i < snake.length; i++) {
            const seg = snake[i];
            const x = seg[0] * CELL_SIZE;
            const y = seg[1] * CELL_SIZE;
            
            // Gradient oluştur (baştan kuyruğa doğru)
            const gradient = ctx.createLinearGradient(x, y, x + CELL_SIZE, y + CELL_SIZE);
            const alpha = 1 - (i / snake.length) * 0.5; // Kuyruğa doğru şeffaflık
            
            if (isMySnake) {
                gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                gradient.addColorStop(0.5, colorInfo.hex);
                gradient.addColorStop(1, `${effect.trail}${Math.floor(alpha * 255).toString(16).padStart(2, '0')}`);
            } else {
                gradient.addColorStop(0, colorInfo.hex);
                gradient.addColorStop(1, `${effect.trail}${Math.floor(alpha * 255).toString(16).padStart(2, '0')}`);
            }
            
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
            
            // Baş için özel efekt
            if (i === 0) {
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(x + CELL_SIZE/2, y + CELL_SIZE/2, CELL_SIZE/4, 0, 2*Math.PI);
                ctx.fill();
            }
        }
        
        if (isMySnake) {
            ctx.restore();
        }
    }

    // Yılan hareket ederken particle oluştur
    function createSnakeParticles(snake, color) {
        if (!snake || snake.length === 0) return;
        
        const head = snake[0];
        const headX = head[0] * CELL_SIZE + CELL_SIZE / 2;
        const headY = head[1] * CELL_SIZE + CELL_SIZE / 2;
        
        // Her 3 frame'de bir particle oluştur
        if (Math.random() < 0.3) {
            for (let i = 0; i < 2; i++) {
                particles.push(new Particle(headX, headY, color));
            }
        }
    }



    // Dokunmatik yön tuşları
    
    // Chat sistemi fonksiyonları
    function initChat() {
        chatContainer = document.getElementById('chat-container');
        chatInput = document.getElementById('chat-input');
        chatMessages = document.getElementById('chat-messages');
        chatError = document.getElementById('chat-error');
        
        // Chat toggle butonu
        document.getElementById('chat-close').addEventListener('click', () => {
            toggleChat();
        });
        
        // Chat input event listener
        chatInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                sendChatMessage();
            }
        });
        

        
        // Chat drag functionality
        const chatHeader = document.getElementById('chat-header');
        chatHeader.addEventListener('mousedown', startChatDrag);
        document.addEventListener('mousemove', onChatDrag);
        document.addEventListener('mouseup', stopChatDrag);
        
        // Chat hover effect
        chatContainer.addEventListener('mouseenter', () => {
            if (!chatVisible) {
                chatContainer.style.display = 'flex';
            }
        });
        
        chatContainer.addEventListener('mouseleave', () => {
            if (!chatVisible) {
                chatContainer.style.display = 'none';
            }
        });
    }
    
    function toggleChat() {
        chatVisible = !chatVisible;
        if (chatVisible) {
            chatContainer.style.display = 'flex';
            // Chat geçmişini iste
            socket.emit('get_chat_history');
        } else {
            chatContainer.style.display = 'none';
        }
    }
    
    function sendChatMessage() {
        const message = chatInput.value.trim();
        if (message.length === 0) return;
        
        socket.emit('chat_message', {
            message: message,
            player_name: nickname
        });
        
        chatInput.value = '';
        hideChatError();
    }
    
    function addChatMessage(chatData) {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'chat-message';
        
        if (chatData.type === 'whisper') {
            messageDiv.classList.add('whisper');
        }
        
        const timestamp = new Date().toLocaleTimeString('tr-TR', { 
            hour: '2-digit', 
            minute: '2-digit' 
        });
        
        let messageText = '';
        if (chatData.type === 'whisper') {
            messageText = `<span class="timestamp">[${timestamp}]</span><span class="player-name" style="color: ${chatData.sender_color}">${chatData.sender_name}</span> fısıldadı: <span class="message-text">${chatData.message}</span>`;
        } else {
            messageText = `<span class="timestamp">[${timestamp}]</span><span class="player-name" style="color: ${chatData.sender_color}">${chatData.sender_name}</span>: <span class="message-text">${chatData.message}</span>`;
        }
        
        messageDiv.innerHTML = messageText;
        chatMessages.appendChild(messageDiv);
        
        // Auto-scroll to bottom
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    function showChatError(message) {
        chatError.textContent = message;
        chatError.style.display = 'block';
    }
    
    function hideChatError() {
        chatError.style.display = 'none';
    }
    
    function startChatDrag(e) {
        if (e.target.id === 'chat-close') return;
        chatDragging = true;
        chatDragStart = {
            x: e.clientX - chatContainer.offsetLeft,
            y: e.clientY - chatContainer.offsetTop
        };
        e.preventDefault();
    }
    
    function onChatDrag(e) {
        if (!chatDragging) return;
        
        const newX = e.clientX - chatDragStart.x;
        const newY = e.clientY - chatDragStart.y;
        
        // Ekran sınırları içinde tut
        const maxX = window.innerWidth - chatContainer.offsetWidth;
        const maxY = window.innerHeight - chatContainer.offsetHeight;
        
        chatContainer.style.left = Math.max(0, Math.min(newX, maxX)) + 'px';
        chatContainer.style.top = Math.max(0, Math.min(newY, maxY)) + 'px';
        chatContainer.style.bottom = 'auto';
        chatContainer.style.right = 'auto';
    }
    
    function stopChatDrag() {
        chatDragging = false;
    }
    
    // T tuşu ile chat toggle
    document.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 't' && !e.ctrlKey && !e.altKey && !e.metaKey) {
            e.preventDefault();
            toggleChat();
        }
    });
    
    // Chat sistemini başlat
    document.addEventListener('DOMContentLoaded', () => {
        initChat();
    });
    </script>
</body>
</html>